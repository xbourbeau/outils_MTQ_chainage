# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OutilsMTQDockWidget
                                 A QGIS plugin
 Regroupe les outils pratiques
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-09-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Xavier Bourbeau
        email                : xavier.bourbeau@transports.gouv.qc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
from qgis.gui import QgisInterface
from qgis.PyQt import uic
from qgis.core import QgsMapLayerProxyModel, QgsFieldProxyModel, QgsVectorLayer, NULL
from qgis.PyQt.QtCore import pyqtSignal, QVariant
from PyQt5.QtCore import Qt
from qgis.PyQt.QtWidgets import QDialog, QToolButton, QMenu, QCheckBox, QWidgetAction, QAction

from ..modules.PluginParametres import PluginParametres
from ..mtq.core import Geocodage, Utilitaire, ReseauSegmenter
from ..mtq.functions import reprojectGeometry
from ..functions.getIcon import getPixmap, getIcon

FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'fenetre_geocodage_inverse.ui'))

class fenetreGeocodageInverse(QDialog, FORM_CLASS):

    closing_window = pyqtSignal()
    
    def __init__(self, iface:QgisInterface, geocode:Geocodage, reseau_context:ReseauSegmenter, parent=None):
        # Référence de l'interface QGIS
        self.iface = iface
        # Module de géocodage 
        self.geocode = geocode
        self.reseau_context = reseau_context
        # Constructor
        super(fenetreGeocodageInverse, self).__init__(parent)
        # Set up l'interface
        self.setupUi(self)

        # Connections
        self.cbx_layer.layerChanged.connect(self.updateLayerCombobox)
        self.btn_calculer.clicked.connect(self.startGeocodageInverse)

        # Class de gestion des paramètres
        self.params = PluginParametres()
        # Définir les filtres pour les combobox
        self.setComboBoxFilters()

        self.gbx_offset.setChecked(False)
        self.gbx_context_layer.setChecked(False)

        # Hide the progress bar
        self.progressBar.hide()

        # Dictionnaire des mots clé à chercher pour chaque champs
        self.dict_field_search = {
            self.cbx_champ_rtss: ["rtss", "rts", "route"],
            self.cbx_champ_chainage_d: ["chainage_d", "ch_d", "chainage", "chaine", "ch"],
            self.cbx_champ_chainage_f: ["chainage_f", "ch_f", "chainage", "chaine", "ch"],
            self.cbx_champ_offset_d: ["offset_d", "dist_d", "offset", "dist"],
            self.cbx_champ_offset_f: ["offset_f", "dist_f", "offset", "dist"],
            self.cbx_champ_context: []
        }
        # Définir l'image du logo de l'outil
        self.lbl_logo.setPixmap(getPixmap("geocodage_inverse"))
        self.lbl_logo.setScaledContents(True)

        self.setActions()
    
    def setActions(self):
        self.chx_formater_rtss = QCheckBox("Formater le RTSS")
        self.chx_formater_rtss.setChecked(self.params.getValue("formater_rtss"))
        self.chx_formater_chainage = QCheckBox("Formater les chainages")
        self.chx_formater_chainage.setChecked(self.params.getValue("formater_chainage"))

        # Définir le menu d'option du RTSS ========================
        self.tbx_option_rtss.setMenu(QMenu())
        self.tbx_option_rtss.setToolTip("Options")
        self.tbx_option_rtss.setPopupMode(QToolButton.InstantPopup)
        self.tbx_option_rtss.setIcon(getIcon("parametres"))

        widget_action_r = QWidgetAction(self.tbx_option_rtss.menu())
        widget_action_r.setDefaultWidget(self.chx_formater_rtss)
        self.tbx_option_rtss.menu().addAction(widget_action_r)

        # Définir le menu d'option du Chainage ========================
        self.tbx_option_chainage.setMenu(QMenu())
        self.tbx_option_chainage.setToolTip("Options")
        self.tbx_option_chainage.setPopupMode(QToolButton.InstantPopup)
        self.tbx_option_chainage.setIcon(getIcon("parametres"))

        widget_action_c = QWidgetAction(self.tbx_option_chainage.menu())
        widget_action_c.setDefaultWidget(self.chx_formater_chainage)
        self.tbx_option_chainage.menu().addAction(widget_action_c)

    def closeEvent(self, event):
        if self.isVisible():
            # Emit signal que la fenêtre vas être fermé
            self.closing_window.emit()
            # Fermer la fenêtre
            event.accept()
    
    def setInterfaceActive(self):
        if self.isVisible(): self.raise_()
        else:
            self.setCurrentLayer()
            self.gbx_context_layer.setEnabled(not self.reseau_context.isEmpty())
            self.show()
        
        self.id_field_rtss = None
        self.id_field_chainage = None
        self.id_field_chainage_f = None
        self.id_field_offset = None
        self.id_field_offset_f = None
        self.id_field_context = None
        # Indicateur de si les types de champs de chainage sont en text (pour le formatage)
        self.formater_chainage_d = None
        self.formater_chainage_f = None

    def geocodageInverseError(self):
        self.progressBar.setValue(0)
        self.progressBar.hide()
        return True

    def formaterChainageDebut(self): self.chx_formater_chainage.isChecked() and self.formater_chainage_d

    def formaterChainageFin(self): self.chx_formater_chainage.isChecked() and self.formater_chainage_d

    def isChainageDebut(self): return self.chx_champ_chainage_d.isChecked() and self.chx_champ_chainage_d.isEnabled()
    
    def isChainageFin(self): return self.chx_champ_chainage_f.isChecked() and self.chx_champ_chainage_f.isEnabled()

    def isOffsetDebut(self): return self.chx_champ_offset_d.isChecked() and self.chx_champ_offset_d.isEnabled()

    def isOffsetFin(self): return self.chx_champ_offset_f.isChecked() and self.chx_champ_offset_f.isEnabled()

    def isContextLayer(self): return self.gbx_context_layer.isChecked() and self.gbx_context_layer.isEnabled() and not self.reseau_context.isEmpty()

    def setCurrentLayer(self):
        """ Permet de définir la couche dans le combobox avec la couche active """
        active_layer = self.iface.activeLayer()
        if not active_layer: return None
        if self.cbx_layer.findText(active_layer.name(), Qt.MatchContains) == -1: return None
        # Définir la couche dans le combobox
        else: self.cbx_layer.setLayer(active_layer)

    def updateLayerCombobox(self, layer):
        """ Permet de suivre les changements de la couche dans le combobox """
        if layer is None: return None
        for cbx, texts in self.dict_field_search.items():
            cbx.setLayer(layer)
            for text in texts:
                idx = cbx.findText(text, Qt.MatchContains)
                if idx != -1: 
                    cbx.setCurrentIndex(idx)
                    break
        # Cacher les valeurs de fin si la couche est ponctuel 
        if layer.geometryType() == 0:
            self.gbx_chainage_fin.hide()
            self.gbx_offset_fin.hide()
        # Sinon afficher les valeurs de fin
        else:
            self.gbx_chainage_fin.show()
            self.gbx_offset_fin.show()

    def setComboBoxFilters(self):
        """ Permet de définir les filtres des comboboxs """
        self.cbx_layer.setExcludedProviders(["WFS"])
        self.cbx_layer.setFilters(QgsMapLayerProxyModel.LineLayer|QgsMapLayerProxyModel.PointLayer|QgsMapLayerProxyModel.PolygonLayer)
        self.cbx_champ_rtss.setFilters(QgsFieldProxyModel.String)
        self.cbx_champ_chainage_d.setFilters(QgsFieldProxyModel.String|QgsFieldProxyModel.Numeric)
        self.cbx_champ_chainage_d.setFilters(QgsFieldProxyModel.String|QgsFieldProxyModel.Numeric)
        self.cbx_champ_offset_d.setFilters(QgsFieldProxyModel.String|QgsFieldProxyModel.Numeric)
        self.cbx_champ_offset_f.setFilters(QgsFieldProxyModel.String|QgsFieldProxyModel.Numeric)
        self.cbx_champ_context.setFilters(QgsFieldProxyModel.String)

    def setFieldsIds(self, layer):
        # Parcourir les champs de la couche
        for i, field in enumerate(layer.fields()):
            if field.name() == self.cbx_champ_rtss.currentField(): self.id_field_rtss = i
            if field.name() == self.cbx_champ_chainage_d.currentField(): 
                self.id_field_chainage = i
                self.formater_chainage_d = field.type() == QVariant.String
            if field.name() == self.cbx_champ_chainage_f.currentField():
                self.id_field_chainage_f = i
                self.formater_chainage_f = field.type() == QVariant.String
            if field.name() == self.cbx_champ_offset_d.currentField(): self.id_field_offset = i
            if field.name() == self.cbx_champ_offset_f.currentField(): self.id_field_offset_f = i
            if field.name() == self.cbx_champ_context.currentField(): self.id_field_context = i

    def startGeocodageInverse(self):
        """ Démare la mise à jour des champs selon le résultat du geocodage inverse """
        # Définir la couche à partir du combobox
        layer = self.cbx_layer.currentLayer()
        # Démarer une session de mise à jour
        try: layer.startEditing()
        except: 
            Utilitaire.criticalMessage(self.iface, f"Erreur: Un problème est survenu lors du démarage de la session de mise à jour sur la couche {layer.name()}")
            return self.geocodageInverseError()
        
        # Définir les identifiants des champs de la couche
        self.setFieldsIds(layer)
        # Montrer la barre de progression
        self.progressBar.show()
        try:
            # Géocoder inverse pour une couche ponctuelle
            if layer.geometryType() == 0: self.geocoderInverseLayerPoint(layer)
            # Géocoder inverse pour une couche linéaire
            elif layer.geometryType() == 1: self.geocoderInverseLayerLine(layer)
            # Géocoder inverse pour une couche linéaire
            elif layer.geometryType() == 2: self.geocoderInverseLayerPolygon(layer)
            # La géometrie de la couche n'a pas été reconnu
            else: 
                Utilitaire.criticalMessage(self.iface, "Erreur type géometrie: La géometries de la couche est invalide") 
                return self.geocodageInverseError()
        # Attraper une erreur lors du géocodage inverse 
        except Exception as e:
            Utilitaire.criticalMessage(self.iface, f"Erreur: Un problème est survenu lors du traitement ({str(e)})")
            return self.geocodageInverseError()

        self.progressBar.setValue(100)
        self.progressBar.hide()
        self.progressBar.setValue(0)
        Utilitaire.succesMessage(self.iface, "Terminé!: Les valeurs ont été calculer avec succès.")
        self.close()

    def geocoderInverseLayerPoint(self, layer:QgsVectorLayer):
        # Nombre d'entité à calculer
        nbr_feature = layer.featureCount()
        # Définir la précision du chainage
        precision = self.params.getValue("precision_chainage")
        # Nom de l'attribut pour le réseau segmenter
        field_context_value = self.params.getValue("field_context_value")
        # Parcourir les entitées de la couche
        for i, feat in enumerate(layer.getFeatures()):
            geom = reprojectGeometry(feat.geometry(), layer.crs(), self.geocode.getCrs())
            # Faire le géocodage inverse pour l'entité
            point_rtss = self.geocode.geocoderInversePoint(geom)
            atts = {}
            # Définir la valeur du RTSS
            if self.gbx_champ_rtss.isChecked():
                atts[self.id_field_rtss] = point_rtss.getRTSS().value(formater=self.chx_formater_rtss.isChecked())
            # Définir la valeur du Chainage
            if self.isChainageDebut():
                atts[self.id_field_chainage] = point_rtss.getChainage().value(
                    formater=self.formaterChainageDebut(),
                    precision=precision)
            # Définir la valeur du Offset
            if self.isOffsetDebut(): atts[self.id_field_offset] = point_rtss.getOffset()
            # Définif la valeur selon le réseau de la couche de contexte
            if self.isContextLayer():
                elems = self.reseau_context.getElementsFromPointRTSS(point_rtss)
                if elems != []: atts[self.id_field_context] = elems[0].getAttribut(field_context_value)
                else: atts[self.id_field_context] = NULL
            # Changer les valeurs de l'entité au dictionnaire des résultats
            layer.changeAttributeValues(feat.id(), atts)
            # Show progress
            self.progressBar.setValue(int(i*100/nbr_feature))

    def geocoderInverseLayerLine(self, layer:QgsVectorLayer):
        # Nombre d'entité à calculer
        nbr_feature = layer.featureCount()
        # Définir la précision du chainage
        precision = self.params.getValue("precision_chainage")
        # Nom de l'attribut pour le réseau segmenter
        field_context_value = self.params.getValue("field_context_value")
        # Parcourir les entitées de la couche
        for i, feat in enumerate(layer.getFeatures()):
            geom = reprojectGeometry(feat.geometry(), layer.crs(), self.geocode.getCrs())
            # Faire le géocodage inverse pour l'entité
            line_rtss = self.geocode.geocoderInverseLine(geom)
            start_point, end_point = line_rtss.startPoint(), line_rtss.endPoint()
            atts = {}
            # Définir la valeur du RTSS
            if self.gbx_champ_rtss.isChecked():
                atts[self.id_field_rtss] = start_point.getRTSS().value(formater=self.chx_formater_rtss.isChecked())
            # Définir la valeur du Chainage début
            if self.isChainageDebut():
                atts[self.id_field_chainage] = start_point.getChainage().value(
                    formater=self.formaterChainageDebut(),
                    precision=precision)
            # Définir la valeur du Offset début
            if self.isOffsetDebut(): atts[self.id_field_offset] = start_point.getOffset()

            # Définir la valeur du Chainage fin
            if self.isChainageFin():
                atts[self.id_field_chainage_f] = end_point.getChainage().value(
                    formater=self.formaterChainageFin(),
                    precision=precision)
            # Définir la valeur du Offset fin
            if self.isOffsetFin(): atts[self.id_field_offset_f] = end_point.getOffset()

            # Définif la valeur selon le réseau de la couche de contexte
            if self.isContextLayer():
                vals = []
                elems = self.reseau_context.getElementsFromPointRTSS(start_point)
                if elems != []: vals.append(str(elems[0].getAttribut(field_context_value)))
                elems = self.reseau_context.getElementsFromPointRTSS(end_point)
                if elems != []: vals.append(str(elems[0].getAttribut(field_context_value)))
                atts[self.id_field_context] = ",".join(set(vals))

            # Changer les valeurs de l'entité au dictionnaire des résultats
            layer.changeAttributeValues(feat.id(), atts)
            # Show progress
            self.progressBar.setValue(int(i*100/nbr_feature))

    def geocoderInverseLayerPolygon(self, layer:QgsVectorLayer):
        # Nombre d'entité à calculer
        nbr_feature = layer.featureCount()
        # Définir la précision du chainage
        precision = self.params.getValue("precision_chainage")
        # Nom de l'attribut pour le réseau segmenter
        field_context_value = self.params.getValue("field_context_value")
        # Parcourir les entitées de la couche
        for i, feat in enumerate(layer.getFeatures()):
            geom = reprojectGeometry(feat.geometry(), layer.crs(), self.geocode.getCrs())
            # Faire le géocodage inverse pour l'entité
            polygon_rtss = self.geocode.geocoderInversePolygon(geom)
            atts = {}
            # Définir la valeur du RTSS
            if self.gbx_champ_rtss.isChecked():
                atts[self.id_field_rtss] = ",".join([r.value(formater=self.chx_formater_rtss.isChecked()) for r in polygon_rtss.listRTSS()])
            # Définir la valeur du Chainage début
            if self.isChainageDebut():
                atts[self.id_field_chainage] = polygon_rtss.getChainageDebut().value(
                    formater=self.formaterChainageDebut(),
                    precision=precision)
            # Définir la valeur du Offset début
            if self.isOffsetDebut(): atts[self.id_field_offset] = polygon_rtss.getOffsetMin()

            # Définir la valeur du Chainage fin
            if self.isChainageFin():
                atts[self.id_field_chainage_f] = polygon_rtss.getChainageFin().value(
                    formater=self.formaterChainageFin(),
                    precision=precision)
            # Définir la valeur du Offset fin
            if self.isOffsetFin(): atts[self.id_field_offset_f] = polygon_rtss.getOffsetMax()

            # Définif la valeur selon le réseau de la couche de contexte
            if self.isContextLayer():
                vals = []
                elems = self.reseau_context.getElementsFromPointRTSS(polygon_rtss.getChainageFin())
                if elems != []: vals.append(str(elems[0].getAttribut(field_context_value)))
                elems = self.reseau_context.getElementsFromPointRTSS(polygon_rtss.getChainageFin())
                if elems != []: vals.append(str(elems[0].getAttribut(field_context_value)))
                atts[self.id_field_context] = ",".join(set(vals))

            # Changer les valeurs de l'entité au dictionnaire des résultats
            layer.changeAttributeValues(feat.id(), atts)
            # Show progress
            self.progressBar.setValue(int(i*100/nbr_feature))