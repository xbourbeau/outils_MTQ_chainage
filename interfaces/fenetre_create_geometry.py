# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OutilsMTQDockWidget
                                 A QGIS plugin
 Regroupe les outils pratiques
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-09-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Xavier Bourbeau
        email                : xavier.bourbeau@transports.gouv.qc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
from mtq.geomapping.PointRTSS import PointRTSS
from qgis.gui import QgisInterface, QgsDockWidget
from qgis.PyQt import uic
from qgis.PyQt.QtCore import pyqtSignal
from PyQt5.QtCore import Qt
from qgis.PyQt.QtWidgets import (QDockWidget, QAction, QMenu, QCheckBox, QToolButton,
                                 QWidgetAction, QSpinBox, QLabel )

from ..modules.PluginParametres import PluginParametres
from ..modules.CompleterRTSS import CompleterRTSS
from ..mtq.core import Geocodage, PointRTSS

FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'fenetre_create_geometry.ui'))

class fenetreCreationGeometrie(QDockWidget, FORM_CLASS):

    closing_window = pyqtSignal()
    set_lock_chainage = pyqtSignal('float')
    set_lock_offset = pyqtSignal('float')
    set_interpolate_on_rtss = pyqtSignal('bool')
    update_moving_point = pyqtSignal(PointRTSS)
    
    def __init__(self, iface:QgisInterface, geocode:Geocodage, parent=None):
        # Référence de l'interface QGIS
        self.iface = iface
        # Module de géocodage 
        self.geocode = geocode
        # Constructor
        super(fenetreCreationGeometrie, self).__init__(parent)
        # Set up l'interface
        self.setupUi(self)
        # Class de gestion des paramètres
        self.params = PluginParametres()
        
        self.hey = True

        self.spx_chainage.valueChanged.connect(self.setValuesFromPoint)
        self.spx_offset.valueChanged.connect(self.setValuesFromPoint)

        self.txt_rtss.textChanged.connect(lambda: self.btn_add.setEnabled(self.isCurrentRTSSValide()))
        self.btn_add.setEnabled(False)

        self.setActions()

    def closeEvent(self, event):
        if self.isVisible():
            # Emit signal que la fenêtre vas être fermé
            self.closing_window.emit()
            # Fermer la fenêtre
            event.accept()
    
    def setInterfaceActive(self):
        if self.isVisible(): self.raise_()
        else:
            # Get all dock widgets in left area
            left_docks = self.iface.mainWindow().findChildren(QgsDockWidget)
            left_docks = [d for d in left_docks if self.iface.mainWindow().dockWidgetArea(d) == Qt.LeftDockWidgetArea]
            # Tabify with last dock widget
            if len(left_docks) > 1: self.iface.mainWindow().tabifyDockWidget(left_docks[-2], self)
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self)
            # Créer le completer
            completer = CompleterRTSS(self.geocode, parent=self.txt_rtss, formater_rtss=False)
            # Appliquer le Completer au LineEdit
            self.txt_rtss.setCompleter(completer)

            self.lockOffset(False)
            self.lockChainage(False)

            self.show()

    def setActions(self):
        # Set Action to lock chainage
        action = QAction(self.params.getIcon("loc"), "Lock", self)
        action.setCheckable(True)
        action.triggered.connect(lambda: self.set_lock_chainage.emit(self.spx_chainage.value()))
        self.act_lock_chainage.setDefaultAction(action)

        # Set Action to lock offset
        action = QAction(self.params.getIcon("loc"), "Lock", self)
        action.setCheckable(True)
        action.triggered.connect(lambda: self.set_lock_offset.emit(self.spx_offset.value()))
        self.act_lock_offset.setDefaultAction(action)

        # Set Action to lock interpolation on RTSS
        action = QAction(self.params.getIcon("chainage"), "intrepoler_on_rtss", self)
        action.setToolTip("Interpoler la géometrie en suivant le RTSS")
        action.setCheckable(True)
        action.setChecked(True)
        action.triggered.connect(lambda state: self.set_interpolate_on_rtss.emit(state))
        self.act_interpolate_rtss.setDefaultAction(action)

        def createSpinBox(param_name):
            spx = QSpinBox()
            spx.setMinimum(0)
            spx.setMaximum(6)
            spx.setValue(self.params.getValue(param_name))
            return spx

        self.chx_precision_chainage = createSpinBox("last_edit_chainage_precision")
        self.chx_precision_chainage.valueChanged.connect(self.updatePrecisionChainage)
        self.updatePrecisionChainage(self.params.getValue("last_edit_chainage_precision"))

        self.chx_precision_offset = createSpinBox("last_edit_offset_precision")
        self.chx_precision_offset.valueChanged.connect(self.updatePrecisionOffset)
        self.updatePrecisionOffset(self.params.getValue("last_edit_offset_precision"))

        # Définir le menu d'option du Chainage ========================
        self.act_param_chainage.setMenu(QMenu())
        self.act_param_chainage.setToolTip("Options")
        self.act_param_chainage.setPopupMode(QToolButton.InstantPopup)
        self.act_param_chainage.setIcon(self.params.getIcon("parametres"))

        widget_action_chainage1 = QWidgetAction(self.act_param_chainage.menu())
        widget_action_chainage1.setDefaultWidget(QLabel("   Précision du chainage   "))
        self.act_param_chainage.menu().addAction(widget_action_chainage1)

        widget_action_chainage = QWidgetAction(self.act_param_chainage.menu())
        widget_action_chainage.setDefaultWidget(self.chx_precision_chainage)
        self.act_param_chainage.menu().addAction(widget_action_chainage)

        # Définir le menu d'option du Offset ========================
        self.act_param_offset.setMenu(QMenu())
        self.act_param_offset.setToolTip("Options")
        self.act_param_offset.setPopupMode(QToolButton.InstantPopup)
        self.act_param_offset.setIcon(self.params.getIcon("parametres"))

        widget_action_offset1 = QWidgetAction(self.act_param_offset.menu())
        widget_action_offset1.setDefaultWidget(QLabel("   Précision du offset   "))
        self.act_param_offset.menu().addAction(widget_action_offset1)

        widget_action_offset = QWidgetAction(self.act_param_offset.menu())
        widget_action_offset.setDefaultWidget(self.chx_precision_offset)
        self.act_param_offset.menu().addAction(widget_action_offset)

    def lockOffset(self, lock:bool):
        self.act_lock_offset.setChecked(lock)
        self.spx_offset.setEnabled(not lock)

    def lockChainage(self, lock:bool):
        self.act_lock_chainage.setChecked(lock)
        self.spx_chainage.setEnabled(not lock)

    def updatePrecisionChainage(self, value:int):
        """ Méthode pour mettre à jour la précision du QSpinBox du chainage """
        self.spx_chainage.setDecimals(value)
        self.params.setValue("last_edit_chainage_precision", value)

    def updatePrecisionOffset(self, value:int):
        """ Méthode pour mettre à jour la précision du QSpinBox du offset """
        self.spx_offset.setDecimals(value)
        self.params.setValue("last_edit_offset_precision", value)

    def isCurrentRTSSValide(self):
        """ Méthode pour verifier si le RTSS dans le LineEdit est valide """
        feat_rtss = self.geocode.get(self.txt_rtss.text())
        return not feat_rtss is None

    def getPointRTSS(self):
        """ Méthode qui perment de retourner le PointRTSS courant dans la fenêtre"""
        return self.geocode.createPoint(self.txt_rtss.text(), self.spx_chainage.value(), self.spx_offset.value())

    def setValuesFromPoint(self, point_rtss:PointRTSS, from_mouse=False):
        if from_mouse:
            self.hey = False
            self.txt_rtss.setText(point_rtss.getRTSS().value())
            self.spx_chainage.setValue(point_rtss.getChainage().value())
            self.spx_offset.setValue(point_rtss.getOffset())
            self.hey = True
        elif self.hey:
            self.update_moving_point.emit(self.getPointRTSS())