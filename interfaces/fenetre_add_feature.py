# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OutilsMTQDockWidget
                                 A QGIS plugin
 Regroupe les outils pratiques
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-09-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Xavier Bourbeau
        email                : xavier.bourbeau@transports.gouv.qc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.core import QgsProject, QgsGeometry, QgsVectorLayerUtils, QgsCoordinateTransform, QgsFieldProxyModel, Qgis
from qgis.gui import QgsRubberBand, QgsMapToolIdentifyFeature, QgsVertexMarker
from qgis.PyQt.QtWidgets import QAction, QDockWidget, QCompleter
from qgis.PyQt import uic
from qgis.PyQt.QtCore import pyqtSignal, QSettings
from qgis.PyQt.QtGui import QIcon, QColor

from ..gestion_parametres import sourceParametre
from ..maptool.mtq_maptool_identify_rtss import MtqMapToolIdentifyRTSS
# Importer les fonction de formatage du module
from ..mtq.format import verifyFormatRTSS, verifyFormatChainage, formaterChainage, formaterRTSS
from ..mtq.fnt import reprojectGeometry

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'fenetre_add_feature.ui'))


class fenetreAddFeature(QDockWidget, FORM_CLASS):

    closing_window = pyqtSignal()

    def __init__(self, iface, layer_rtss, geocode, parent=None):
        # Référance de l'interface QGIS
        self.iface = iface
        # Référence de la carte 
        self.canvas = self.iface.mapCanvas()
        # Module de géocodage 
        self.geocode = geocode
        # Référance de la couche des RTSS utilisé par le plugin
        self.layer_rtss = layer_rtss
        # Suivi des connexions au signal d'update des spinBox
        self.spinbox_connected = True
        
        # Constructor
        super(fenetreAddFeature, self).__init__(parent)
        # Set up l'interface
        self.setupUi(self)
        
        # Class de gestion des paramètres
        self.gestion_parametre = sourceParametre()
        # Répertoire du plugin
        self.plugin_dir = os.path.dirname(os.path.dirname(__file__))
        
        # Définir le nombre de décimals selon les paramètres du plugin
        precision = self.gestion_parametre.getParam("precision_chainage").getValue()
        self.spx_chainage_d.setDecimals(precision)
        self.spx_chainage_f.setDecimals(precision)
        
        # Geometrie temportaire pour la représentation du segment
        self.nouvelle_geom_ligne = QgsRubberBand(self.canvas, True)
        # Couleur d'une ligne en cours de numérisation dans les paramètres de QGIS
        red = QSettings().value("qgis/digitizing/line_color_red", 251, type=int)
        green = QSettings().value("qgis/digitizing/line_color_green", 103, type=int)
        blue = QSettings().value("qgis/digitizing/line_color_blue", 17, type=int)
        alpha = QSettings().value("qgis/digitizing/line_color_alpha", 200, type=int)
        
        # Appliquer la couleur au segment temporaire
        self.nouvelle_geom_ligne.setColor(QColor(red, green, blue, alpha))
        # Appliquer la largeur de la ligne, des paramètres de QGIS, au segment temporaire 
        self.nouvelle_geom_ligne.setWidth(QSettings().value("qgis/digitizing/line_width", 1, type=int))
        
        # Geometry temporaire de la représentation d'un point
        self.nouvelle_geom_point = QgsVertexMarker(self.canvas)
        # Appliquer la couleur au point temporaire
        self.nouvelle_geom_point.setFillColor(QColor(red, green, blue, alpha))
        # Appliquer une taille de symbole
        self.nouvelle_geom_point.setIconSize(7)
        # Représenter le point temporaire sous forme de cercle
        self.nouvelle_geom_point.setIconType(QgsVertexMarker.ICON_CIRCLE)
        
        # Créer le completer
        completer = QCompleter(self.geocode.getListRTSS(self.gestion_parametre.getParam("formater_rtss").getValue(), sorted=True))
        completer.setCaseSensitivity(0)
        completer.setModelSorting(2)
        # Appliquer le Completer au LineEdit
        self.txt_rtss.setCompleter(completer)
        
        # Définir les paramètres par défault de la fenêtre
        self.setDefaultValues()
        # Vérifier les conditions d'utilisation de la fenêtre pour la couche active dans le projet
        self.verifyActiveLayer()
        
        # Appliquer les filtres de champs sur les comboBox du choix de champs
        self.cbx_rtss.setFilters(QgsFieldProxyModel.String)
        for cbx in (self.cbx_chainage_d, self.cbx_chainage_f, self.cbx_dist_d, self.cbx_dist_f):
            cbx.setFilters(QgsFieldProxyModel.String|QgsFieldProxyModel.Numeric)
        
        # -------------------- Connextion --------------------------
        self.iface.currentLayerChanged.connect(self.verifyActiveLayer)
        self.btn_annuler.clicked.connect(self.setDefaultValues)
        self.btn_close.clicked.connect(self.close)
        self.btn_add_feature.clicked.connect(self.addGeocodedFeature)
        self.txt_rtss.textChanged.connect(self.updateLineEditRTSS)
        self.spx_chainage_d.valueChanged.connect(self.setChainageDebut)
        self.spx_chainage_f.valueChanged.connect(self.setChainageFin)
        self.spx_dist_d.valueChanged.connect(self.setOffsetDebut)
        self.spx_dist_f.valueChanged.connect(self.setOffsetFin)
                
        # ------------------ Action de selection un RTSS ------------------
        # Chemin vers l'icon de l'action
        icon = QIcon(os.path.realpath(os.path.join(self.plugin_dir, 'icons/identify.png')))
        # Créer l'action de selectionner le RTSS sur la carte
        self.action_identifiy_rtss = QAction(icon, 'Selectionner le RTSS sur la carte', self)
        # Connecter l'action à la méthode qui créer et rend le QgsMapTool actif
        self.action_identifiy_rtss.triggered.connect(self.setMaptoolIdentifyRTSS)
        # Définir l'action comme checkable
        self.action_identifiy_rtss.setCheckable(True)
        # Définir le tool tip de l'action
        self.action_identifiy_rtss.setToolTip('Permet de selectionner un RTSS sur la carte')
        # Associer l'actions au buttons de la fenêtres
        self.act_select_rtss.setDefaultAction(self.action_identifiy_rtss)
        
        # Définir le QgsMapTool pour la selection d'un RTSS
        self.maptool_identifiy_rtss = None
        
    #
    def closeEvent(self, event):
        # -------------------- Déconnextion --------------------------
        self.iface.currentLayerChanged.disconnect(self.verifyActiveLayer)
        self.btn_annuler.clicked.disconnect(self.setDefaultValues)
        self.btn_close.clicked.disconnect(self.close)
        self.btn_add_feature.clicked.disconnect(self.addGeocodedFeature)
        self.txt_rtss.textChanged.disconnect(self.updateLineEditRTSS)
        self.spx_chainage_d.valueChanged.disconnect(self.setChainageDebut)
        self.spx_chainage_f.valueChanged.disconnect(self.setChainageFin)
        self.spx_dist_d.valueChanged.disconnect(self.setOffsetDebut)
        self.spx_dist_f.valueChanged.disconnect(self.setOffsetFin)
        
        # Désactivée le QgsMapTool de selection d'un RTSS
        if self.maptool_identifiy_rtss: self.maptool_identifiy_rtss.deactivate()
        # Rétirer les géometrie temportaire de la carte
        self.canvas.scene().removeItem(self.nouvelle_geom_ligne)
        self.canvas.scene().removeItem(self.nouvelle_geom_point)
        # Emit signal que la fenêtre vas être fermé
        self.closing_window.emit()
        # Fermer la fenêtre
        event.accept()

    ''' Méthode qui permet de définir les valeurs par défault des widjets de la fenêtres '''
    def setDefaultValues(self):
        # Définir un RTSS vide
        self.txt_rtss.setText('')
        # Définir les spinBox des chainage et offset à 0
        self.spx_chainage_d.setValue(0)
        self.spx_dist_d.setValue(0.0)
        self.spx_chainage_f.setValue(0)
        self.spx_dist_f.setValue(0.0)
        # Masquer les geometries temporaire
        self.resetTemporaryGeom()
    
    ''' Méthode pour de cacher les deux géometries temporaires '''
    def resetTemporaryGeom(self):
        self.nouvelle_geom_point.hide()
        self.nouvelle_geom_ligne.hide()
    
    '''
        Méthode qui vérifie que la couche active dans la carte respect les contraintes d'utilisation de la fenêtres.
        La couche doit être:
            - Vectoriel (de type ligne ou point)
            - En édition
    '''
    def verifyActiveLayer(self):
        # Référance à la couche active dans la carte
        active_layer = self.iface.activeLayer() 
        #self.btn_add_feature.setEnabled(False)
        # Suivi de l'état des contraintes 
        is_in_edition, is_lineaire = False, False
        # Définir le nom de la couche active par défault
        layer_name = ''
        # Vérifier qu'il y a bien une couche active
        if active_layer:
            # Définir le nom de la couche active avec la couche active
            layer_name = f"{active_layer.name()} ({active_layer.crs().authid()})"
            # Vérifier que la couche est vectoriel
            if active_layer.type() == 0:
                # Définir l'idicateur de la géometry de la couche 
                is_lineaire = active_layer.geometryType() == 1
                # Vérifier la contrainte que la couche doit être de type ligne ou point
                if active_layer.geometryType() == 0 or is_lineaire:
                    # Définir l'idicateur de la contrainte que la couche doit être en édition
                    is_in_edition = active_layer.isEditable()
                    # Indiquer la couche de référence pour les comboBox des choix de champs
                    for cbx in (self.cbx_rtss, self.cbx_chainage_d, self.cbx_chainage_f, self.cbx_dist_d, self.cbx_dist_f):
                        cbx.setLayer(active_layer)
                    # -------------- Connecter et déconnecter la méthode au signaux de changement de statut d'édition
                    # Disconnect, will be reconnected
                    try: active_layer.editingStarted.disconnect(self.verifyActiveLayer) 
                    except: pass
                    # When it becomes active layer again
                    try: active_layer.editingStopped.disconnect(self.verifyActiveLayer) 
                    except: pass
                    # Connecter la méthode au signaux de changement de statut d'édition
                    active_layer.editingStarted.connect(self.verifyActiveLayer)
                    active_layer.editingStopped.connect(self.verifyActiveLayer)
        
        # Afficher le nom de la couche active dans la fenêtre
        self.lbl_current_layer.setText(layer_name)
        # Enable/Disable selon si la couche est en edition
        self.groupBox_geom.setEnabled(is_in_edition)
        self.groupBox_att.setEnabled(is_in_edition)
        self.spx_chainage_f.setEnabled(is_lineaire)
        self.spx_dist_f.setEnabled(is_lineaire)
        # Update la géometrie temporaire si la couche est valide et en édition
        if is_in_edition: self.updateGeoSegmentTemporaire()
        # Sinon, désactiver le QgsMapTool et masqué les geometries temporaire
        else:
            #self.setMaptoolIdentifyRTSS(False)
            if self.maptool_identifiy_rtss: self.maptool_identifiy_rtss.deactivate()
            self.resetTemporaryGeom()
            
    ''' Méthode qui construit et rend actif le QgsMapTool de selection d'un RTSS sur la carte '''
    def setMaptoolIdentifyRTSS(self, activated):
        # Vérifier si le bouton de l'action associé est activé ou désactiver
        if activated:
            # Créer un instance de QgsMapToolIdentifyFeature pour identifier un feature de la couche RTSS dans la carte
            self.maptool_identifiy_rtss = MtqMapToolIdentifyRTSS(self.canvas, self.layer_rtss, self.geocode)
            #self.maptool_identifiy_rtss = QgsMapToolIdentifyFeature(self.canvas, self.layer_rtss)
            self.maptool_identifiy_rtss.identifyRTSS.connect(lambda rtss: self.txt_rtss.setText(rtss))
            # Définir l'action associé au QgsMapTool
            self.maptool_identifiy_rtss.setAction(self.action_identifiy_rtss)
            # Rendre actif dans la carte le QgsMapTool créer
            self.canvas.setMapTool(self.maptool_identifiy_rtss)
        else: self.maptool_identifiy_rtss.deactivate()
    
    ''' Méthode qui permet d'afficher une géométrie temporaire à partir des informations de la fenêtre. '''
    def updateGeoSegmentTemporaire(self):
        # Masquer les géometries temporaire
        self.resetTemporaryGeom()
        # Indicateur d'une geometrie valide à ajouter dans la couche active
        is_geom_valide = False
        temp_geom = QgsGeometry()
        # Vérifer si la couche active est de type linéaire
        if self.iface.activeLayer().geometryType() == 1:
            # Création de la géometrie temporaire à partir des informations dans la fenêtre
            temp_geom = self.geocode.geocoder(
                rtss=self.txt_rtss.text(),
                chainage=self.spx_chainage_d.value(),
                chainage_f=self.spx_chainage_f.value(),
                offset=self.spx_dist_d.value(),
                offset_f=self.spx_dist_f.value())
            
            # Vérifier si la géometrie est valide pour l'ajouter dans la couche active
            is_geom_valide = temp_geom.wkbType() == 2
            if is_geom_valide:
                # Reprojecter la géometrie dans la même projection que la carte
                temp_geom = self.reprojectGeometry(temp_geom, self.geocode.crs, QgsProject.instance().crs())
                if temp_geom: self.nouvelle_geom_ligne.setToGeometry(temp_geom)
                else: is_geom_valide = False
            
        # Vérifer si la couche active est de type ponctuel
        elif self.iface.activeLayer().geometryType() == 0:
            # Géometrie temporaire
            temp_geom = self.geocode.geocoder(
                self.txt_rtss.text(),
                self.spx_chainage_d.value(),
                offset=self.spx_dist_d.value())
            # Vérifier si la géometrie est valide pour l'ajouter dans la couche active
            is_geom_valide = temp_geom.wkbType() == 1
            if is_geom_valide:
                # Reprojecter la géometrie dans la même projection que la carte
                temp_geom = self.reprojectGeometry(temp_geom, self.geocode.crs, QgsProject.instance().crs())
                if temp_geom:
                    self.nouvelle_geom_point.setCenter(temp_geom.asPoint())
                    self.nouvelle_geom_point.show()
                else: is_geom_valide = False
                    
        # Rendre le bouton actif ou inactif selon l'indicateur pour accepter d'ajouter un feature
        self.btn_add_feature.setEnabled(is_geom_valide)
        
    ''' Méthode qui permet d'ajouter la géometrie temporaire à la couche active '''
    def addGeocodedFeature(self):
        # Référance à la couche active dans la carte
        active_layer = self.iface.activeLayer()
        # Aller chercher la geometrie temporaire selon le type de géometrie de la couche
        if active_layer.geometryType() == 0: geom = QgsGeometry().fromPointXY(self.nouvelle_geom_point.center())
        elif active_layer.geometryType() == 1: geom = self.nouvelle_geom_ligne.asGeometry()
        # Reprojecter la géometrie dans la même projection que la couche active
        geom = self.reprojectGeometry(geom, QgsProject.instance().crs(), active_layer.crs())
        # Vérifer que la reprojection à fonctionné
        if geom:
            # Définir les valeurs par défault des attributs 
            new_atts = {}
            # Vérifier si des attributs devrait être ajouter
            if self.groupBox_att.isChecked():
                # Ajouter les attributs au dictionnaire 
                atts = {self.cbx_rtss.currentField(): self.txt_rtss.text(),
                    self.cbx_chainage_d.currentField(): self.spx_chainage_d.value(),
                    self.cbx_chainage_f.currentField(): self.spx_chainage_f.value(),
                    self.cbx_dist_d.currentField(): self.spx_dist_d.value(),
                    self.cbx_dist_f.currentField(): self.spx_dist_f.value()}
                # Référence des champs de la couche active 
                fields = active_layer.fields()
                # Parcourir les champs de la couche
                for i, field in enumerate(fields):
                    # Vérifier si le nom du champ est bien dans la couche active
                    if field.name() in atts:
                        # Définir la valeur de l'attributs selon le type de champ selectionnée
                        if field.typeName() == 'string': val = str(atts[field.name()])
                        else: val = atts[field.name()]
                        # Ajouter les attributs au dictionnaire des attributs à ajouter à la couches
                        new_atts[i] = val
                        
            # Créer un nouvelle entitée de la couche active avec les attributs et la geometrie défini 
            new_feat = QgsVectorLayerUtils.createFeature(active_layer, geom, new_atts)
            # Considérer par défault que l'entité créer est valide
            feat_is_valide = True
            # Parcourir les attributs de l'entitée
            for i in new_atts.keys():
                # Vérifer si l'attribut ne respect pas les contraintes ou la longueure du champs
                if not QgsVectorLayerUtils.validateAttribute(active_layer, new_feat, i)[0] or fields.field(i).length() < len(str(new_atts[i])):
                    # Notifier l'utilisateur de l'erreur
                    widget = self.iface.messageBar().createMessage(f"La valeur {new_atts[i]} ne respect pas les contraintes du champ {fields.field(i).name()}")
                    # Afficher le message
                    self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
                    feat_is_valide = False
                    break
            # Vérifer si l'entité est valide
            if feat_is_valide:
                # Ajouter l'entité créer dans la couche active
                active_layer.addFeature(new_feat)
                # Indiquer à l'utilisateur que l'entité à bien été ajouter
                widget = self.iface.messageBar().createMessage(f"L'entitée a été ajoutée dans la couche {active_layer.name()}")
                # Afficher le message
                self.iface.messageBar().pushWidget(widget, Qgis.Success, duration=1)
                # Masquer la geometrie temporaire
                self.resetTemporaryGeom()
                # Update l'affichage de la carte
                self.canvas.refresh()
    
    ''' Méthode qui permet d'exécuter la fonction de reprojection d'une géometrie pour afficher un message si celle-ci n'est pas réussi '''
    def reprojectGeometry(self, geom, crs_origine, crs_dest):
        geom = reprojectGeometry(geom, crs_origine, crs_dest)
        if geom: return geom
        else:
            # Notifier l'utilisateur de l'erreur
            widget = self.iface.messageBar().createMessage(f"Erreur lors de la conversion en la projection {crs_origine.authid()} vers {crs_dest.authid()}")
            # Afficher le message
            self.iface.messageBar().pushWidget(widget, Qgis.Critical, duration=3)
            return False
        
    
    ''' Méthode qui est connecté au changement de numéro de RTSS dans la fenêtre'''
    def updateLineEditRTSS (self, rtss):
        # Vérifer si le RTSS est dans la module de géocodage
        feat_rtss = self.geocode.getRTSS(rtss)
        # Définir les chainage min/max du RTSS 
        if feat_rtss: cd, cf = feat_rtss.getChainageDebut(), feat_rtss.getChainageFin()
        else: cd, cf = 0, 50000
        # Appliquer les chainage min/max dans la fenêtre
        self.spx_chainage_d.setMaximum(cf)
        self.spx_chainage_d.setMinimum(cd)
        self.spx_chainage_f.setMaximum(cf)
        self.spx_chainage_f.setMinimum(cd)
        self.lbl_chainage.setText("Chainage ({}, {})".format(cd, cf))
        # Mettre à jour la geometrie temporaire
        self.updateGeoSegmentTemporaire()
    
    
    ''' Méthode qui est connecté au changement de chainage de début '''
    def setChainageDebut(self, chainage):
        # Mettre à jour le chainage de fin si la case perpendiculaire est cochée
        if self.chx_perpendiculaire.isChecked(): self.spx_chainage_f.setValue(chainage)
        # Mettre à jour la géometrie temporaire
        self.updateGeoSegmentTemporaire()
    
    ''' Méthode qui est connecté au changement de chainage de fin '''
    def setChainageFin(self, chainage):
        # Mettre à jour le chainage de fin si la case perpendiculaire est cochée
        if self.chx_perpendiculaire.isChecked(): self.spx_chainage_d.setValue(chainage)
        # Mettre à jour la géometrie temporaire
        self.updateGeoSegmentTemporaire()
    
    ''' Méthode qui est connecté au changement de offset de début '''
    def setOffsetDebut(self, dist):
        # Mettre à jour le chainage de fin si la case perpendiculaire est cochée
        if self.chk_parallel.isChecked(): self.spx_dist_f.setValue(dist)
        # Mettre à jour la géometrie temporaire
        self.updateGeoSegmentTemporaire()
    
    ''' Méthode qui est connecté au changement de offset de fin '''
    def setOffsetFin(self, dist):
        # Mettre à jour le chainage de fin si la case perpendiculaire est cochée
        if self.chk_parallel.isChecked(): self.spx_dist_d.setValue(dist)
        # Mettre à jour la géometrie temporaire
        self.updateGeoSegmentTemporaire()

pass















