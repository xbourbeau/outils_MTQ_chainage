# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OutilsMTQDockWidget
                                 A QGIS plugin
 Regroupe les outils pratiques
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-09-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Xavier Bourbeau
        email                : xavier.bourbeau@transports.gouv.qc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
from qgis.gui import QgsRubberBand, QgsVertexMarker
from qgis.PyQt.QtGui import QColor
from qgis.PyQt import uic, QtWidgets
from qgis.core import QgsProject, QgsFieldProxyModel, QgsVectorLayer, QgsWkbTypes, QgsField, Qgis, QgsGeometry, QgsExpression, QgsVectorLayerUtils
from qgis.PyQt.QtCore import pyqtSignal
from PyQt5.QtCore import Qt, QVariant
from qgis.PyQt.QtWidgets import QDockWidget, QListWidgetItem, QMenu, QAction, QMessageBox, QApplication, QCompleter 

from ..mtq.core import Geocodage, FeatRTSS, reprojectGeometry
from ..modules.PluginParametres import PluginParametres

FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'fenetre_add_feature.ui'))


class fenetreAddFeature(QDockWidget, FORM_CLASS):

    closing_window = pyqtSignal()

    def __init__(self, iface, geocode:Geocodage, parent=None):
        # Référence de l'interface QGIS
        self.iface = iface
        # Référence de la carte 
        self.canvas = self.iface.mapCanvas()
        # Module de géocodage 
        self.geocode = geocode
        # Désigne le type de géométrie utilisée. 1 = point, 0 = ligne, 2 = polygone
        self.geomType = 3
        # Constructor
        super(fenetreAddFeature, self).__init__(parent)
        # Set up l'interface
        self.setupUi(self)
        # Class de gestion des paramètres
        self.params = PluginParametres()
        # Répertoire du plugin
        self.plugin_dir = os.path.dirname(os.path.dirname(__file__))
        
        """ ----------------------------------------- Connections ----------------------------------------------""" 
        # Permet de réinitialiser les valeurs lorsqu'on appuie sur le bouton "Annuler"
        self.btn_annuler.clicked.connect(self.setDefaultValues)
        # Afin de ferme la fenêtre lorsque le boutton fermer est cliqué
        self.btn_close.clicked.connect(self.close)
        # Permet d'ajouter les géométries à la couche active lorsqu'on appuie sur le bouton "Ajouter"
        self.btn_add_feature.clicked.connect(self.addGeocodedFeature)
        # Permet de détecter un changement dans la case du numéro du RTSS
        self.txt_rtss.textChanged.connect(self.verifyRTSS)
        # Liste des spinboxs de chainage
        self.chain_list = [self.spx_chainage_Pol_1, self.spx_chainage_Pol_2, self.spx_chainage_Pol_3, self.spx_chainage_Pol_4, self.spx_chainage_P, self.spx_chainage_L_1, self.spx_chainage_L_2]
        # Liste des spinboxs de distance
        self.dist_list = [self.spx_dist_Pol_1, self.spx_dist_Pol_3, self.spx_dist_Pol_2, self.spx_dist_Pol_4, self.spx_dist_P, self.spx_dist_L_1, self.spx_dist_L_2]
        # Liste des checkboxs pour rendre les segments perpendiculaires au RTSS
        self.perp_list = [self.chx_perp_p1, self.chx_perp_p2, self.chx_perp_p3, self.chx_perp_p4]
        # Liste vide pour stocker les checkboxs de perpendicularité cochés
        self.checked_perp = []  
        # Liste des checkboxs pour rendre les segments parallèles au RTSS
        self.para_list = [self.chx_para_p1, self.chx_para_p2, self.chx_para_p3, self.chx_para_p4]
        # Liste vide pour stocker les checkboxs de parallélité cochés
        self.checked_para = []
        # Liste des comboboxs de choix de champ de la couche active
        self.att_list = [self.cbx_rtss_P, self.cbx_rtss_L, self.cbx_rtss_Pol, self.cbx_chainage_P, self.cbx_dist_P, self.cbx_chainage_L_1, self.cbx_chainage_L_2, self.cbx_dist_L_1, self.cbx_dist_L_2, self.cbx_chainage_Pol_1, self.cbx_chainage_Pol_2, self.cbx_chainage_Pol_3, self.cbx_chainage_Pol_4, self.cbx_dist_Pol_1, self.cbx_dist_Pol_2, self.cbx_dist_Pol_3, self.cbx_dist_Pol_4]
        # Liste des boutons qui ajoute un champ à la couche active
        self.add_att_list = [self.psh_rtss_p, self.psh_rtss_l, self.psh_rtss_pol, self.psh_c_p, self.psh_d_p, self.psh_c1_l, self.psh_c2_l, self.psh_d1_l, self.psh_d2_l, self.psh_c1_pol, self.psh_c2_pol, self.psh_c3_pol, self.psh_c4_pol, self.psh_d1_pol, self.psh_d2_pol, self.psh_d3_pol, self.psh_d4_pol]
        # Connection des valeurs de spinbox de chainage au tracage de géométrie temporaire
        for chain in self.chain_list: chain.valueChanged.connect(self.createGeometry)
        # Connection des valeurs de spinbox de distance au tracage de géométrie temporaire
        for dist in self.dist_list: dist.valueChanged.connect(self.createGeometry)
        # Connection des valeurs de spinbox de chainage au point de référence
        for chain in self.chain_list: chain.valueChanged.connect(self.updatePointReferenceTemp)
        # Connection des valeurs de spinbox de distance au point de référence
        for dist in self.dist_list: dist.valueChanged.connect(self.updatePointReferenceTemp)
        # Connection des checkboxs pour rendre les segments perpendiculaires au RTSS
        for perp in self.perp_list: perp.toggled.connect(self.perpendiculaireChecked)
        # Connection des checkboxs pour rendre les segments parallèles au RTSS
        for para in self.para_list: para.toggled.connect(self.paralleleChecked)
        # Connection du checkbox pour rendre le traçage de ligne perpendiculaire au RTSS
        self.chx_perpendiculaire_L.toggled.connect(self.perpendiculaireChecked)
        # Connection du checkbox pour rendre le traçage de polygone perpendiculaire au RTSS
        self.chx_perpendiculaire_Pol.toggled.connect(self.perpendiculaireChecked)
        # Connection du checkbox pour rendre le traçage de ligne parallèle au RTSS
        self.chx_parallele_L.toggled.connect(self.paralleleChecked)
        # Connection du checkbox pour rendre le traçage de polygone parallèle au RTSS
        self.chk_parallel_Pol.toggled.connect(self.paralleleChecked)
        # Connection des boutons d'ajout de champ à la fonction d'ajout de champ
        for push in self.add_att_list: push.clicked.connect(self.addFieldTracage)
        
        # Créer le completer
        completer = QCompleter(self.geocode.getListRTSS(self.params.getValue("formater_rtss"), sorted=True))
        completer.setCaseSensitivity(0)
        completer.setModelSorting(2)
        # Appliquer le Completer au LineEdit
        self.txt_rtss.setCompleter(completer)
        
        # Appliquer les filtres de champs sur les comboBox du choix de champs
        for cbx in self.att_list: cbx.setFilters(QgsFieldProxyModel.String|QgsFieldProxyModel.Numeric)
        self.cbx_rtss_P.setFilters(QgsFieldProxyModel.String)
        self.cbx_rtss_L.setFilters(QgsFieldProxyModel.String)
        self.cbx_rtss_Pol.setFilters(QgsFieldProxyModel.String)
        
    """  ----------------------------------------------- Liste des fonctions -----------------------------------------------------------""" 
    def closeEvent(self, event):
        if self.isVisible():
            # Déconnections du détection de changement de focus des widgets
            QtWidgets.qApp.focusChanged.disconnect(self.on_focusChanged)
            # Retirer les géometries temporaires
            for geom in self.temp_geom: self.canvas.scene().removeItem(geom)
            self.canvas.scene().removeItem(self.extremity_temp)
            # Emit signal que la fenêtre vas être fermé
            self.closing_window.emit()
            # Fermer la fenêtre
            event.accept()
 
    def show(self):
        """ ------------------------------------ Paramètres des géométries temporaires ----------------------------------------""" 
        
        # Géométrie temporaire pour la représentation d'un point
        self.geom_point = QgsVertexMarker(self.canvas)
        # Type de marqueur
        self.geom_point.setIconType(2)
        # Définit la grosseur du marqueur
        self.geom_point.setIconSize(30)
        self.geom_point.setPenWidth(3)
        
        # Géométrie temporaire pour la représentation d'une ligne
        self.geom_line = QgsRubberBand(self.canvas)
        self.geom_line.setColor(QColor(0, 0, 255, 180))
        self.geom_line.setWidth(3)
        self.geom_line.hide()
        
        # Geometrie temportaire pour la représentation d'un polygone
        self.geom_poly = QgsRubberBand(self.canvas)
        self.geom_poly.setColor(QColor(0, 0, 255, 180))
        self.geom_poly.setWidth(3)
        self.geom_poly.hide()
        
        # Groupe des géométries temporaires
        self.temp_geom = [self.geom_point, self.geom_line, self.geom_poly]
        # Couleur vert avec un peu de transparence
        for geom in self.temp_geom: geom.setColor(QColor(10, 240, 58, 180))
        for geom in self.temp_geom: geom.hide()
        
        # Geometrie temportaire pour la représentation d'un segment
        self.extremity_temp = QgsVertexMarker(self.canvas)
        # Couleur vert avec un peu de transparence
        self.extremity_temp.setColor(QColor(13, 61, 219, 100))
        self.extremity_temp.setIconType(QgsVertexMarker.ICON_CIRCLE)
        self.extremity_temp.setFillColor(QColor(13, 61, 219, 0))
        self.extremity_temp.setIconSize(7)
        self.extremity_temp.setPenWidth(2)
        
        # Connection du détection de changement de focus des widgets
        QtWidgets.qApp.focusChanged.connect(self.on_focusChanged)
        
        self.setDefaultValues()
 
    def setGeometries(self, geoms):
        self.geom_point, self.geom_line, self.geom_poly = geoms
        self.temp_geom = [self.geom_point, self.geom_line, self.geom_poly]
 
    """ ---------------- Fonction qui permet d'afficher un point temporaire pour identifier le point sélectionné lors de la sélection d'un spinbox de ligne ou de polygone -------------------""" 
    def on_focusChanged(self, old, new):
        point_geom = None
        # Point de début pour le traçage linéaire
        if new in [self.spx_chainage_L_1, self.spx_dist_L_1]:
            point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_L_1.value(), self.spx_dist_L_1.value())
        # Point de fin pour le traçage linéaire
        elif new in [self.spx_chainage_L_2, self.spx_dist_L_2]:
            point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_L_2.value(), self.spx_dist_L_2.value())
        # Point de début pour le traçage de polygone
        elif new in [self.spx_chainage_Pol_1, self.spx_dist_Pol_1]:
            point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_Pol_1.value(), self.spx_dist_Pol_1.value())
        # Deuxième point pour le traçage de polygone
        elif new in [self.spx_chainage_Pol_2, self.spx_dist_Pol_3]:
            point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_Pol_2.value(), self.spx_dist_Pol_3.value())
        # Troisième point pour le traçage de polygone
        elif new in [self.spx_chainage_Pol_3, self.spx_dist_Pol_2]:
            point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_Pol_3.value(), self.spx_dist_Pol_2.value())
        # Point de fin pour le traçage de polygone
        elif new in [self.spx_chainage_Pol_4, self.spx_dist_Pol_4]:
            point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_Pol_4.value(), self.spx_dist_Pol_4.value())
        # Afficher le point temporaire
        if point_geom and point_geom.wkbType() == 1: 
            self.extremity_temp.setCenter(point_geom.asPoint())
            self.extremity_temp.show()
        else: self.extremity_temp.hide()
        
    """ ---------------- Fonction qui permet d'afficher un point temporaire pour identifier le point sélectionné lors du changement de valeur d'un spinbox de ligne ou de polygone -------------------""" 
    def updatePointReferenceTemp(self):
        # Identifie le spinbox qui a envoyé le signal
        sender = self.sender()
        point_geom = None
        if self.feat_rtss:
            # Point de début pour le traçage linéaire
            if sender in [self.spx_chainage_L_1, self.spx_dist_L_1]:
                point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_L_1.value(), self.spx_dist_L_1.value())
            # Point de fin pour le traçage linéaire
            elif sender in [self.spx_chainage_L_2, self.spx_dist_L_2]:
                point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_L_2.value(), self.spx_dist_L_2.value())
            # Point de début pour le traçage de polygone
            elif sender in [self.spx_chainage_Pol_1, self.spx_dist_Pol_1]:
                point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_Pol_1.value(), self.spx_dist_Pol_1.value())
            # Deuxième point pour le traçage de polygone
            elif sender in [self.spx_chainage_Pol_2, self.spx_dist_Pol_3]:
                point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_Pol_2.value(), self.spx_dist_Pol_3.value())
            # Troisième point pour le traçage de polygone
            elif sender in [self.spx_chainage_Pol_3, self.spx_dist_Pol_2]:
                point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_Pol_3.value(), self.spx_dist_Pol_2.value())
            # Point de fin pour le traçage de polygone
            elif sender in [self.spx_chainage_Pol_4, self.spx_dist_Pol_4]:
                point_geom = self.feat_rtss.getPointFromChainage(self.spx_chainage_Pol_4.value(), self.spx_dist_Pol_4.value())
            # Afficher le point temporaire
            if point_geom and point_geom.wkbType() == 1: 
                self.extremity_temp.setCenter(point_geom.asPoint())
                self.extremity_temp.show()
            
    """ ---------------------------- Fonction qui permet de définir des paramètres à partir de la couche active par défaut -------------------------------""" 
    def updateCurrentLayer(self, layer):
        # Remettre les valeurs par défaut
        self.setDefaultValues()
        # Rendre la boite de texte de choix de RTSS utilisable
        self.txt_rtss.setReadOnly(False)
        # Afficher le nom de la couche active
        self.lbl_current_layer.setText(layer.name())
        # Changer le stack widget selon le type de géométrie de la couche active
        if layer.geometryType() == QgsWkbTypes.PointGeometry: self.stackedWidget.setCurrentIndex(1)
        elif layer.geometryType() == QgsWkbTypes.LineGeometry: self.stackedWidget.setCurrentIndex(0)
        elif layer.geometryType() == QgsWkbTypes.PolygonGeometry: self.stackedWidget.setCurrentIndex(2)
        # Ajuster la valeur de geomType en fonction de l'index du stack
        self.geomType = self.stackedWidget.currentIndex()
        # Ajouter les champs de la couche active aux combobox
        self.setFieldsCombobox(layer)
    """ --------------------------------- Initialiser les valeurs par défaut lors du début du traçage ---------------------------------------------""" 
    def setDefaultValues(self):
        # Définir un RTSS vide
        self.txt_rtss.setText('')
        # Définir les spinBox des chainage et offset à 0
        for chain in self.chain_list: chain.setValue(0)
        for dist in self.dist_list: dist.setValue(0.0)
        # Décocher les options parallèles et perpendiculaires
        for perp in self.perp_list: perp.setCheckState(Qt.Unchecked)
        for para in self.para_list: para.setCheckState(Qt.Unchecked)
        self.chx_perpendiculaire_L.setCheckState(Qt.Unchecked)
        self.chx_parallele_L.setCheckState(Qt.Unchecked)
        self.chk_parallel_Pol.setCheckState(Qt.Unchecked)
        self.chx_perpendiculaire_Pol.setCheckState(Qt.Unchecked)
        # Réinitialiser les géométries temporaires
        self.geom_point.hide()
        self.geom_line.reset()
        self.geom_poly.reset()
        self.extremity_temp.hide()
        self.btn_add_feature.setEnabled(False)
    
    """ -------------------------- Permet de valider le RTSS --------------------------------------""" 
    def verifyRTSS(self, new_RTSS):
        #Permet d'aller chercher le RTSS de façon lisible pour le programme
        self.feat_rtss = self.geocode.getRTSS(new_RTSS)
        # Définir les chainage min/max du RTSS s'il existe 
        if self.feat_rtss: 
            cd, cf = int(self.feat_rtss.getChainageDebut()), int(self.feat_rtss.getChainageFin())
            # Activer les boites de traçage de géométrie
            self.gbx_geom_P.setEnabled(True)
            self.gbx_geom_L.setEnabled(True)
            self.gbx_geom_Pol.setEnabled(True)
        # Définir les chainage min/max par défaut si le RTSS n'existe pas
        else:
            cd, cf = 0, 50000
            # Désactiver les boites de traçage de géométrie
            self.gbx_geom_P.setEnabled(False)
            self.gbx_geom_L.setEnabled(False)
            self.gbx_geom_Pol.setEnabled(False)
        # Appliquer les chainage min/max dans la fenêtre
        for chain in self.chain_list: chain.setMaximum(cf)
        for chain in self.chain_list: chain.setMinimum(cd)
        self.lbl_chainage.setText("Chainage ({}, {})".format(cd, cf))
        self.lbl_chainage_2.setText("Chainage ({}, {})".format(cd, cf))
        self.lbl_chainage_3.setText("Chainage ({}, {})".format(cd, cf))

    """ -------------------------------------- Ajout de champs pour les valeurs de traçage ---------------------------------------------""" 
    def addFieldTracage(self):
        # Identifie le bouton qui a envoyé le signal
        send_psh = self.sender()
        # Retourne le nom du bouton qui a envoyé le signal
        psh_name = send_psh.objectName()
        # Référence à la couche active
        active_layer = self.iface.activeLayer()
        layer_name = active_layer.name()
        # Dictionnaire des boutons et leur champ associé
        field_mapping = {
            'psh_rtss_p': ('rtss', QVariant.String),
            'psh_rtss_l': ('rtss', QVariant.String),
            'psh_rtss_pol': ('rtss', QVariant.String),
            'psh_c_p': ('chainage', QVariant.Int),
            'psh_d_p': ('distance', QVariant.Double),
            'psh_c1_l': ('chainage_d', QVariant.Int),
            'psh_c2_l': ('chainage_f', QVariant.Int),
            'psh_d1_l': ('distance_d', QVariant.Double),
            'psh_d2_l': ('distance_f', QVariant.Double),
            'psh_c1_pol': ('chainage_1', QVariant.Int),
            'psh_c2_pol': ('chainage_2', QVariant.Int),
            'psh_c3_pol': ('chainage_3', QVariant.Int),
            'psh_c4_pol': ('chainage_4', QVariant.Int),
            'psh_d1_pol': ('distance_1', QVariant.Double),
            'psh_d2_pol': ('distance_2', QVariant.Double),
            'psh_d3_pol': ('distance_3', QVariant.Double),
            'psh_d4_pol': ('distance_4', QVariant.Double),
        }
        # Ajout du champ à la couche active lorsqu'un bouton de la liste est appuyé
        if psh_name in field_mapping:
            field_name, field_type = field_mapping[psh_name]
            if field_name not in [field.lower() for field in active_layer.fields().names()]:
                new_field = QgsField(field_name, field_type)
                self.active_layer.addAttribute(new_field)
                self.active_layer.updateFields()
                self.active_layer.triggerRepaint()
                widget = self.iface.messageBar().createMessage(f'Le champ "{field_name}" à été ajouté la couche "{layer_name}".')
                self.iface.messageBar().pushWidget(widget, Qgis.Success, duration=2)

                # Choisir le champ à ajouter selon le bouton appuyé
                if 'psh_rtss' in psh_name:
                    self.cbx_rtss_P.setField(field_name) if self.geomType == 1 else self.cbx_rtss_L.setField(field_name) if self.geomType == 0 else self.cbx_rtss_Pol.setField(field_name)
                elif 'psh_c_p' in psh_name:
                    self.cbx_chainage_P.setField(field_name)
                elif 'psh_d_p' in psh_name:
                    self.cbx_dist_P.setField(field_name)
                elif 'psh_c1_l' in psh_name:
                    self.cbx_chainage_L_1.setField(field_name)
                elif 'psh_c2_l' in psh_name:
                    self.cbx_chainage_L_2.setField(field_name)
                elif 'psh_d1_l' in psh_name:
                    self.cbx_dist_L_1.setField(field_name)
                elif 'psh_d2_l' in psh_name:
                    self.cbx_dist_L_2.setField(field_name)
                elif 'psh_c1_pol' in psh_name:
                    self.cbx_chainage_Pol_1.setField(field_name)
                elif 'psh_c2_pol' in psh_name:
                    self.cbx_chainage_Pol_2.setField(field_name)
                elif 'psh_c3_pol' in psh_name:
                    self.cbx_chainage_Pol_3.setField(field_name)
                elif 'psh_c4_pol' in psh_name:
                    self.cbx_chainage_Pol_4.setField(field_name)
                elif 'psh_d1_pol' in psh_name:
                    self.cbx_dist_Pol_1.setField(field_name)
                elif 'psh_d2_pol' in psh_name:
                    self.cbx_dist_Pol_2.setField(field_name)
                elif 'psh_d3_pol' in psh_name:
                    self.cbx_dist_Pol_3.setField(field_name)
                elif 'psh_d4_pol' in psh_name:
                    self.cbx_dist_Pol_4.setField(field_name)
            # Indiquer si le champ à ajouter est déjà dans la couche active
            else:
                widget = self.iface.messageBar().createMessage(f'Le champ "{field_name}" existe déjà dans la couche "{layer_name}".')
                self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
                
    """ ---------------------------------- Gestion des ComboBoxs pour la sélection des champs ------------------------------------"""        
    def setFieldsCombobox(self, active_layer):
        for cbx in self.att_list: cbx.setLayer(active_layer)
        # Gestion des champs d'une couche de point
        if self.geomType == 1: 
            # Ajouter les champs existants correspondants de la couche active dans les comboboxs
            self.cbx_rtss_P.setCurrentIndex(self.cbx_rtss_P.findText("rtss", Qt.MatchFixedString))
            self.cbx_chainage_P.setCurrentIndex(self.cbx_chainage_P.findText("chainage", Qt.MatchFixedString))
            self.cbx_dist_P.setCurrentIndex(self.cbx_dist_P.findText("distance", Qt.MatchFixedString))
        # Gestion des champs d'une couche de ligne
        elif self.geomType == 0:
            # Ajouter les champs existants correspondants de la couche active dans les comboboxs
            self.cbx_rtss_L.setCurrentIndex(self.cbx_rtss_L.findText("rtss", Qt.MatchFixedString))
            self.cbx_chainage_L_1.setCurrentIndex(self.cbx_chainage_L_1.findText("chainage_d", Qt.MatchFixedString))
            self.cbx_dist_L_1.setCurrentIndex(self.cbx_dist_L_1.findText("distance_d", Qt.MatchFixedString))
            self.cbx_chainage_L_2.setCurrentIndex(self.cbx_chainage_L_2.findText("chainage_f", Qt.MatchFixedString))
            self.cbx_dist_L_2.setCurrentIndex(self.cbx_dist_L_2.findText("distance_f", Qt.MatchFixedString))
        # Gestion des champs d'une couche de polygone
        elif self.geomType == 2:
            # Ajouter les champs existants correspondants de la couche active dans les comboboxs
            self.cbx_rtss_Pol.setCurrentIndex(self.cbx_rtss_Pol.findText("rtss", Qt.MatchFixedString))
            self.cbx_chainage_Pol_1.setCurrentIndex(self.cbx_chainage_Pol_1.findText("chainage_1", Qt.MatchFixedString))
            self.cbx_dist_Pol_1.setCurrentIndex(self.cbx_dist_Pol_1.findText("distance_1", Qt.MatchFixedString))
            self.cbx_chainage_Pol_2.setCurrentIndex(self.cbx_chainage_Pol_2.findText("chainage_2", Qt.MatchFixedString))
            self.cbx_dist_Pol_2.setCurrentIndex(self.cbx_dist_Pol_2.findText("distance_2", Qt.MatchFixedString))
            self.cbx_chainage_Pol_3.setCurrentIndex(self.cbx_chainage_Pol_3.findText("chainage_3", Qt.MatchFixedString))
            self.cbx_dist_Pol_3.setCurrentIndex(self.cbx_dist_Pol_3.findText("distance_3", Qt.MatchFixedString))
            self.cbx_chainage_Pol_4.setCurrentIndex(self.cbx_chainage_Pol_4.findText("chainage_4", Qt.MatchFixedString))
            self.cbx_dist_Pol_4.setCurrentIndex(self.cbx_dist_Pol_4.findText("distance_4", Qt.MatchFixedString))
        
    """ ---------------------------------- Tracer la géométrie temporaire ----------------------------------""" 
    def createGeometry(self):
        # Vérifier qu'un RTSS, chainage de début et offset sont valide
        if self.feat_rtss:
            # Si la couche active est de type point
            if self.geomType == 0:
                print("allo")
                # Créer une géometrie ponctuelle temporaire
                self.geom_point.setToGeometry(self.feat_rtss.getPointFromChainage(self.spx_chainage_P.value(), self.spx_dist_P.value()).asPoint())
                self.geom_point.show()
            # Si la couche active est de type ligne
            elif self.geomType == 1:
                # Regarder si le mode perpendiculaire est activé
                self.perpendiculaireChecked()
                # Regarder si le mode parallèle est activé
                self.paralleleChecked()
                # Créer une géometrie linéaire temporaire
                self.geom_line.setToGeometry(self.feat_rtss.getLineFromChainage(self.spx_chainage_L_1.value(), self.spx_chainage_L_2.value(), self.spx_dist_L_1.value(), self.spx_dist_L_2.value()))
                self.geom_line.show()
            # Si la couche active est de type polygone
            elif self.geomType == 2:
                # Regarder si le mode perpendiculaire est activé
                self.perpendiculaireChecked()
                # Regarder si le mode parallèle est activé
                self.paralleleChecked()
                # Créer une géometrie polygonale temporaire
                self.geom_poly.setToGeometry(self.feat_rtss.getPolygonFromChainage(self.spx_chainage_Pol_1.value(), self.spx_chainage_Pol_2.value(), self.spx_dist_Pol_1.value(), self.spx_dist_Pol_2.value(), self.spx_chainage_Pol_3.value(), self.spx_chainage_Pol_4.value(), self.spx_dist_Pol_3.value(), self.spx_dist_Pol_4.value()))
                self.geom_poly.show()
     
    """ ------------------------------------- Méthode qui permet d'ajouter la géometrie temporaire à la couche active --------------------------------------------""" 
    def addGeocodedFeature(self):
        # Aller chercher la geometrie temporaire selon le type de géometrie de la couche
        if self.geomType == 1: geom = QgsGeometry().fromPointXY(self.geom_point.center())
        elif self.geomType == 0: geom = self.geom_line.asGeometry()
        elif self.geomType == 2: geom = self.geom_poly.asGeometry()
        # Reprojecter la géometrie dans la même projection que la couche active
        geom = reprojectGeometry(geom, QgsProject.instance().crs(), self.active_layer.crs())
        # Vérifer que la reprojection à fonctionné
        if geom:
            # Définir les valeurs par défault des attributs 
            new_atts = {}
            # Vérifier si des attributs devrait être ajouter
            if self.gbx_att_P.isChecked():
                # Ajouter les attributs au dictionnaire 
                atts = {self.cbx_rtss_P.currentField(): self.txt_rtss.text(),
                    self.cbx_chainage_P.currentField(): int(self.spx_chainage_P.value()),
                    self.cbx_dist_P.currentField(): float(self.spx_dist_P.value())}
            elif self.gbx_att_L.isChecked():
                # Ajouter les attributs au dictionnaire 
                atts = {self.cbx_rtss_L.currentField(): self.txt_rtss.text(),
                    self.cbx_chainage_L_1.currentField(): int(self.spx_chainage_L_1.value()),
                    self.cbx_chainage_L_2.currentField(): int(self.spx_chainage_L_2.value()),
                    self.cbx_dist_L_1.currentField(): float(self.spx_dist_L_1.value()),
                    self.cbx_dist_L_2.currentField(): float(self.spx_dist_L_2.value())}
            elif self.gbx_att_Pol.isChecked():
                # Ajouter les attributs au dictionnaire 
                atts = {self.cbx_rtss_Pol.currentField(): self.txt_rtss.text(),
                    self.cbx_chainage_Pol_1.currentField(): int(self.spx_chainage_Pol_1.value()),
                    self.cbx_chainage_Pol_2.currentField(): int(self.spx_chainage_Pol_2.value()),
                    self.cbx_dist_Pol_1.currentField(): float(self.spx_dist_Pol_1.value()),
                    self.cbx_dist_Pol_2.currentField(): float(self.spx_dist_Pol_3.value()),
                    self.cbx_chainage_Pol_3.currentField(): int(self.spx_chainage_Pol_3.value()),
                    self.cbx_chainage_Pol_4.currentField(): int(self.spx_chainage_Pol_4.value()),
                    self.cbx_dist_Pol_3.currentField(): float(self.spx_dist_Pol_2.value()),
                    self.cbx_dist_Pol_4.currentField(): float(self.spx_dist_Pol_4.value())}
            else: atts = {}
            # Référence des champs de la couche active 
            fields = self.active_layer.fields()
            # Parcourir les champs de la couche
            for i, field in enumerate(fields):
                # Vérifier si le nom du champ est bien dans la couche active
                if field.name() in atts:
                    # Définir la valeur de l'attributs selon le type de champ selectionnée
                    if field.typeName() == 'string': val = str(atts[field.name()])
                    else: val = atts[field.name()]
                    # Ajouter les attributs au dictionnaire des attributs à ajouter à la couches
                    new_atts[i] = val
                        
            # Créer un nouvelle entitée de la couche active avec les attributs et la geometrie défini 
            new_feat = QgsVectorLayerUtils.createFeature(self.active_layer, geom, new_atts)
            # Considérer par défault que l'entité créer est valide
            feat_is_valide = True
            # Parcourir les attributs de l'entitée
            for i in new_atts.keys():
                # Vérifer si l'attribut respecte les contraintes du champs
                expression = QgsExpression('\'{}\''.format(new_atts[i]))
                if expression.hasParserError():
                    # Notifier l'utilisateur de l'erreur
                    widget = self.iface.messageBar().createMessage(f"La valeur {new_atts[i]} ne respect pas les contraintes du champ {fields.field(i).name()}")
                    # Afficher le message
                    self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
                    feat_is_valide = False
                    break
            # Vérifer si l'entité est valide
            if feat_is_valide:
                # Ajouter l'entité créer dans la couche active
                self.active_layer.addFeature(new_feat)
                # Indiquer à l'utilisateur que l'entité à bien été ajouter
                widget = self.iface.messageBar().createMessage(f"L'entitée a été ajoutée dans la couche {self.active_layer.name()}")
                # Afficher le message
                self.iface.messageBar().pushWidget(widget, Qgis.Success, duration=1)
                # Masquer la geometrie temporaire
                self.geom_point.hide()
                self.geom_line.reset()
                self.geom_poly.reset()
                self.point_ref_temp.reset()
                # Update l'affichage de la carte
                self.canvas.refresh()
            else:
                widget = self.iface.messageBar().createMessage("L'entité ne peut pas être ajouté à la couche active, veuillez revérifier les champs et la géométrie de l'entité.")
                self.iface.messageBar().pushWidget(widget, Qgis.Critical, duration=3)
    
    """ ----------------------- Enregistre les informations reçu par l'outil lors de traçage de géométries ----------------------------""" 
    def listInformation(self, list):
        # Information envoyé quand la couche active est de type point
        if self.geomType == 1:
            rtss = list[0]
            chainage = list[1]
            distance = list[2]
            self.txt_rtss.setText(rtss.getRTSS(True))
            self.spx_chainage_P.setValue(chainage)
            self.spx_dist_P.setValue(distance)
        # Information envoyé quand la couche active est de type ligne
        elif self.geomType == 0:
            rtss = list[0] 
            chainage1 = list[1]
            distance1 = list[2]
            chainage2 = list[3]
            distance2 = list[4]
            self.txt_rtss.setText(rtss.getRTSS(True))
            self.spx_chainage_L_1.setValue(chainage1)
            self.spx_dist_L_1.setValue(distance1)
            self.spx_chainage_L_2.setValue(chainage2)
            self.spx_dist_L_2.setValue(distance2)
        # Information envoyé quand la couche active est de type polygone
        elif self.geomType == 2:
            rtss = list[0] 
            chainage1 = list[1]
            distance1 = list[2]
            chainage2 = list[3]
            distance2 = list[4]
            chainage3 = list[5]
            distance3 = list[6]
            chainage4 = list[7]
            distance4 = list[8]
            self.txt_rtss.setText(rtss.getRTSS(True))
            self.spx_chainage_Pol_1.setValue(chainage1)
            self.spx_dist_Pol_1.setValue(distance1)
            self.spx_chainage_Pol_2.setValue(chainage2)
            self.spx_dist_Pol_2.setValue(distance3)
            self.spx_chainage_Pol_3.setValue(chainage3)
            self.spx_dist_Pol_3.setValue(distance2)
            self.spx_chainage_Pol_4.setValue(chainage4)
            self.spx_dist_Pol_4.setValue(distance4)
        
    """ ------------------------------------- Active le mode de traçage perpendiculaire -------------------------------------------------""" 
    def perpendiculaireChecked(self):
        # Quand perpendiculaire est coché pour les lignes:
        if self.chx_perpendiculaire_L.isChecked():
            # Décocher parallèle
            self.chx_parallele_L.setCheckState(Qt.Unchecked)
            # Rendre la fin de la ligne égale au début de ligne
            self.spx_chainage_L_2.setValue(self.spx_chainage_L_1.value())

        # Quand perpendiculaire est coché pour le traçage de polygones:
        elif self.chx_perpendiculaire_Pol.isChecked():
            # Décocher parallèle
            self.chk_parallel_Pol.setCheckState(Qt.Unchecked)
        
        # Gestion de la perpendicularité quand le traçage par clique est terminé ou ignoré
        else:
            # Lorsqu'il y a des boites cochées:
            if self.perp_list:
                for box_c in self.perp_list:
                    # Si les boites cochées ne sont pas dans la liste
                    if box_c.isChecked() and box_c not in self.checked_perp:
                        # Ajouter les boites cochées à la liste
                        self.checked_perp.append(box_c)
                # Quand une boite est décochée:
                for box_u in self.checked_perp:
                    # Si les boites décochées sont dans la liste
                    if not box_u.isChecked() and box_u in self.checked_perp:
                       # Retirer les boites non cochées de la liste
                       self.checked_perp.remove(box_u)

                # Décocher la première boite cochée de la liste si la liste comporte 3 boites cochées
                if len(self.checked_perp) >= 3:
                    self.checked_perp[0].setCheckState(Qt.Unchecked)

                # Lorsque deux boites perpendiculaires sont cochées:
                if len(self.checked_perp) == 2:
                    index0 = self.perp_list.index(self.checked_perp[0])
                    index1 = self.perp_list.index(self.checked_perp[1])
                    dist0 = self.dist_list[index0].value()
                    dist1 = self.dist_list[index1].value()
                    # Si les deux distances sont identiques
                    if dist0 == dist1: 
                        widget = self.iface.messageBar().createMessage("Les valeurs des distances des points sélectionnés sont identiques, les points ne peuvent pas être perpendiculaire.")
                        # Afficher le message
                        self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
                    else:
                        # Point 2 perpendiculaire à point 1
                        if self.chx_perp_p1 == self.checked_perp[0] and self.chx_perp_p2 == self.checked_perp[1]:
                            self.spx_chainage_Pol_2.setValue(self.spx_chainage_Pol_1.value())
                        # Point 3 perpendiculaire à point 1
                        elif self.chx_perp_p1 == self.checked_perp[0] and self.chx_perp_p3 == self.checked_perp[1]:
                            self.spx_chainage_Pol_3.setValue(self.spx_chainage_Pol_1.value())
                        # Point 4 perpendiculaire à point 1
                        elif self.chx_perp_p1 == self.checked_perp[0] and self.chx_perp_p4 == self.checked_perp[1]:
                            self.spx_chainage_Pol_4.setValue(self.spx_chainage_Pol_1.value())
                        # Point 1 perpendiculaire à point 2
                        elif self.chx_perp_p2 == self.checked_perp[0] and self.chx_perp_p1 == self.checked_perp[1]:
                            self.spx_chainage_Pol_1.setValue(self.spx_chainage_Pol_2.value())
                        # Point 3 perpendiculaire à point 2
                        elif self.chx_perp_p2 == self.checked_perp[0] and self.chx_perp_p3 == self.checked_perp[1]:
                            self.spx_chainage_Pol_3.setValue(self.spx_chainage_Pol_2.value())
                        # Point 4 perpendiculaire à point 2
                        elif self.chx_perp_p2 == self.checked_perp[0] and self.chx_perp_p4 == self.checked_perp[1]:
                            self.spx_chainage_Pol_4.setValue(self.spx_chainage_Pol_2.value())
                        # Point 1 perpendiculaire à point 3
                        elif self.chx_perp_p3 == self.checked_perp[0] and self.chx_perp_p1 == self.checked_perp[1]:
                            self.spx_chainage_Pol_1.setValue(self.spx_chainage_Pol_3.value())
                        # Point 2 perpendiculaire à point 3
                        elif self.chx_perp_p3 == self.checked_perp[0] and self.chx_perp_p2 == self.checked_perp[1]:
                            self.spx_chainage_Pol_2.setValue(self.spx_chainage_Pol_3.value())
                        # Point 4 perpendiculaire à point 3
                        elif self.chx_perp_p3 == self.checked_perp[0] and self.chx_perp_p4 == self.checked_perp[1]:
                            self.spx_chainage_Pol_4.setValue(self.spx_chainage_Pol_3.value())
                        # Point 1 perpendiculaire à point 4
                        elif self.chx_perp_p4 == self.checked_perp[0] and self.chx_perp_p1 == self.checked_perp[1]:
                            self.spx_chainage_Pol_1.setValue(self.spx_chainage_Pol_4.value())
                        # Point 2 perpendiculaire à point 4
                        elif self.chx_perp_p4 == self.checked_perp[0] and self.chx_perp_p2 == self.checked_perp[1]:
                            self.spx_chainage_Pol_2.setValue(self.spx_chainage_Pol_4.value())
                        # Point 3 perpendiculaire à point 4
                        elif self.chx_perp_p4 == self.checked_perp[0] and self.chx_perp_p3 == self.checked_perp[1]:
                            self.spx_chainage_Pol_3.setValue(self.spx_chainage_Pol_4.value())
                    # Sortir les boites cochées de la liste en les décochant
                    self.checked_perp[0].setCheckState(Qt.Unchecked)

    """ ------------------------------------- Active le mode de traçage parallèle -------------------------------------------------""" 
    def paralleleChecked(self):
        # Si parallèle est coché pour les lignes:
        if self.chx_parallele_L.isChecked():
            # Décocher perpendiculaire
            self.chx_perpendiculaire_L.setCheckState(Qt.Unchecked)
            self.spx_dist_L_2.setValue(self.spx_dist_L_1.value())
        
        # Si parallèle est coché pour les polygones
        elif self.chk_parallel_Pol.isChecked():
            # Décocher perpendiculaire
            self.chx_perpendiculaire_Pol.setCheckState(Qt.Unchecked)
        
        # Gestion de la parallélité quand le traçage par clique est terminé ou ignoré
        else:
            # Lorsqu'il y a des boites cochées:
            if self.para_list:
                for chx_c in self.para_list:
                    # Si les boites cochées ne sont pas dans la liste
                    if chx_c.isChecked() and chx_c not in self.checked_para:
                        # Ajouter les boites cochées à une liste
                        self.checked_para.append(chx_c)
                # Quand une boite est décochée:
                for chx_u in self.checked_para:
                    # Si les boites décochées sont dans la liste
                    if not chx_u.isChecked() and chx_u in self.checked_para:
                       # Retirer le boites décochées de la liste
                       self.checked_para.remove(chx_u)
                       
                # Décocher la première boite cochée de la liste si la liste comporte 3 boites cochées
                if len(self.checked_para) >= 3:
                    self.checked_para[0].setCheckState(Qt.Unchecked)
                
                # Lorsque deux boites parallèles sont cochées:
                if len(self.checked_para) == 2:
                    index0 = self.para_list.index(self.checked_para[0])
                    index1 = self.para_list.index(self.checked_para[1])
                    chain0 = self.chain_list[index0].value()
                    chain1 = self.chain_list[index1].value()
                    # Si les deux chainages sont identiques
                    if chain0 == chain1: 
                        widget = self.iface.messageBar().createMessage("Les valeurs des chainages des points sélectionnés sont identiques, donc les points ne peut pas être parallèle.")
                        # Afficher le message
                        self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
                    else:
                        # Point 2 parallèle à point 1
                        if self.chx_para_p1 == self.checked_para[0] and self.chx_para_p2 == self.checked_para[1]:
                            self.spx_dist_Pol_3.setValue(self.spx_dist_Pol_1.value())
                        # Point 3 parallèle à point 1
                        elif self.chx_para_p1 == self.checked_para[0] and self.chx_para_p3 == self.checked_para[1]:
                            self.spx_dist_Pol_2.setValue(self.spx_dist_Pol_1.value())
                        # Point 4 parallèle à point 1
                        elif self.chx_para_p1 == self.checked_para[0] and self.chx_para_p4 == self.checked_para[1]:
                            self.spx_dist_Pol_4.setValue(self.spx_dist_Pol_1.value())
                        # Point 1 parallèle à point 2
                        elif self.chx_para_p2 == self.checked_para[0] and self.chx_para_p1 == self.checked_para[1]:
                            self.spx_dist_Pol_1.setValue(self.spx_dist_Pol_3.value())
                        # Point 3 parallèle à point 2
                        elif self.chx_para_p2 == self.checked_para[0] and self.chx_para_p3 == self.checked_para[1]:
                            self.spx_dist_Pol_2.setValue(self.spx_dist_Pol_3.value())
                        # Point 4 parallèle à point 2
                        elif self.chx_para_p2 == self.checked_para[0] and self.chx_para_p4 == self.checked_para[1]:
                            self.spx_dist_Pol_4.setValue(self.spx_dist_Pol_3.value())
                        # Point 1 parallèle à point 3
                        elif self.chx_para_p3 == self.checked_para[0] and self.chx_para_p1 == self.checked_para[1]:
                            self.spx_dist_Pol_1.setValue(self.spx_dist_Pol_2.value())
                        # Point 2 parallèle à point 3
                        elif self.chx_para_p3 == self.checked_para[0] and self.chx_para_p2 == self.checked_para[1]:
                            self.spx_dist_Pol_3.setValue(self.spx_dist_Pol_2.value())
                        # Point 4 parallèle à point 3
                        elif self.chx_para_p3 == self.checked_para[0] and self.chx_para_p4 == self.checked_para[1]:
                            self.spx_dist_Pol_4.setValue(self.spx_dist_Pol_2.value())
                        # Point 1 parallèle à point 4
                        elif self.chx_para_p4 == self.checked_para[0] and self.chx_para_p1 == self.checked_para[1]:
                            self.spx_dist_Pol_1.setValue(self.spx_dist_Pol_4.value())
                        # Point 2 parallèle à point 4
                        elif self.chx_para_p4 == self.checked_para[0] and self.chx_para_p2 == self.checked_para[1]:
                            self.spx_dist_Pol_3.setValue(self.spx_dist_Pol_4.value())
                        # Point 3 parallèle à point 4
                        elif self.chx_para_p4 == self.checked_para[0] and self.chx_para_p3 == self.checked_para[1]:
                            self.spx_dist_Pol_2.setValue(self.spx_dist_Pol_4.value())
                    # Sortir les boites cochées de la liste en les décochant
                    self.checked_para[0].setCheckState(Qt.Unchecked)
     
pass

