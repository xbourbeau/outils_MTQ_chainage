# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OutilsMTQ
                                 A QGIS plugin
 Regroupe les outils pratiques
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Xavier Bourbeau
        email                : xavier.bourbeau@transports.gouv.qc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Import QGIS
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtGui import QIcon, QFont, QKeySequence, QColor
from qgis.PyQt.QtWidgets import QAction, QComboBox, QLineEdit, QCompleter, QLabel, QMessageBox, QToolButton, QMenu, QPushButton
from qgis.core import (QgsProject, QgsGeometry, QgsVectorLayer, QgsProcessingFeatureSourceDefinition, QgsExpressionContextUtils,
                        QgsApplication, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsRectangle, Qgis, QgsPointXY)
from qgis.gui import QgsVertexMarker, QgsRubberBand
import processing
import pyplugin_installer

# Import General
import os
import math
from packaging import version

# Import from Plugin
from .provider import Provider
from .gestion_parametres import sourceParametre

# Import Interfaces
from .interfaces.fenetre_parametre import fenetreParametre
from .interfaces.fenetre_add_feature import fenetreAddFeature
from .interfaces.fenetre_selection_interval import fenetreSelectionInterval
from .interfaces.fenetre_transect import fenetreTransect

from .maptool.mtq_maptool_distance_rtss import MtqMapToolLongueurRTSS
from .maptool.mtq_maptool_new_ecusson import MtqMapToolNewEcusson
from .maptool.mtq_maptool_open_svn import MtqMapToolOpenSVN

from .mtq.geocodage import geocodage
from .mtq.format import formaterChainage, formaterRTSS, deformaterChainage, verifyFormatChainage
from .mtq.fnt import validateLayer, reprojectGeometry
from .mtq.openSIGO import openSIGO

from .functions.addLayerToMap import addLayerToMap
from .functions.getVisibleFeatures import getVisibleFeatures
from .functions.getToolTipPosition import getToolTipPosition

class MtqPluginChainage:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.cwd = os.path.dirname(os.path.realpath(__file__))

        # ******  À CHANGER LORS DE NOUVELLE MISE À JOUR **********
        self.version = "3.2.3"
        self.new_plugin = None
        self.new_version = None
        self.documentation = "file://sstao00-adm005/TridentAnalyst/Plugin_chainage_mtq/Documentation/Index.html"
        # *********************************************************

        # Declare instance attributes
        self.actions = []
        # Liste des actions pouvant êtres disabled
        self.tool_disabled = []
        self.tool_enabled = []
        self.menu_name = u"&Outils de chainage (MTQ)"
        self.menu = self.menu_name
        
        # ToolBar des outils de chainage
        self.toolbar_chaine = self.iface.addToolBar(u'Outils chainage (MTQ)')
        
        # Référence du provider des scripts de géotraitment
        self.provider = None       
        # Indicateur de l'état du plugin
        self.plugin_is_active = False
        
        # Class qui gère l'enregistrement des paramètres
        self.gestion_parametre = sourceParametre()
        self.gestion_parametre.getParam("ecusson_path").setValue(self.plugin_dir)
        
        # Information de la couche RTSS
        self.layer_rtss = None
        
        # Information sur les mapTools du plugin
        self.tool_mesurer = None
        self.tool_add_ecusson = None
        self.tool_open_svn = None
        
        # Instance de la class geocodage 
        self.geocode = geocodage(
            rtss_features=None,
            crs=None,
            nom_champ_rtss=self.gestion_parametre.getParam("field_num_rtss").getValue(), 
            nom_champ_long=self.gestion_parametre.getParam("field_chainage_fin").getValue(),
            nom_champ_chainage_d=self.gestion_parametre.getParam("field_chainage_debut").getValue(),
            precision=self.gestion_parametre.getParam("precision_chainage").getValue())
        # Interfaces
        self.dlg_params = None
        self.dlg_add_feat = None
        self.dlg_interval_chainage = None
        self.dlg_transect = None
        
        
        # Reférence à la carte
        self.canvas = self.iface.mapCanvas()
        # Vérifier si le plugin peut être lancée si une couche est ajouter au projet
        self.canvas.layersChanged.connect(self.setPluginActive)
        
        # Geometry temporaire (segment)
        #self.segment_offset_temporaire = QgsRubberBand(self.canvas)
        #self.segment_offset_temporaire.setColor(QColor("#e4741e"))
        #self.segment_offset_temporaire.setWidth(1.5)
        
        # Define le pointeur du chainage
        self.vertex_marker_snap = QgsVertexMarker(self.canvas)
        self.vertex_marker_snap.setIconType(QgsVertexMarker.ICON_X)
        self.vertex_marker_snap.setColor(Qt.black)
        self.vertex_marker_snap.setIconSize(10)
        self.vertex_marker_snap.setPenWidth(2)
        self.vertex_marker_snap.hide()
        
        # Définir le text pour le suivi du chainage
        self.mouse_text = self.canvas.scene().addText("allo")
        self.mouse_text.hide()
        
        self.checkForPluginUpdate()

    def add_action(
        self,
        name,
        help_str,
        callback,
        enabled_flag=True,
        add_to_disabled_liste=False,
        add_to_enabled_liste=False,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        isCheckable=False):
        
        action = None
        param_action = self.gestion_parametre.getAction(name)
        if param_action:
            if param_action.getValue():
                icon = QIcon(param_action.getIcon())
                action = QAction(icon, help_str, parent)
                action.triggered.connect(callback)
                action.setCheckable(isCheckable)
                action.setEnabled(enabled_flag)

                if status_tip is not None: action.setStatusTip(status_tip)
                if whats_this is not None: action.setWhatsThis(whats_this)
                if add_to_toolbar: self.toolbar_chaine.addAction(action)
                if add_to_menu: self.iface.addPluginToMenu(self.menu,action)
                if add_to_disabled_liste: self.tool_disabled.append(action)
                if add_to_enabled_liste: self.tool_enabled.append(action)

                self.actions.append(action)

        return action
    
    def add_widjet(
        self,
        widjet,
        width=None,
        height=None,
        font=None,
        add_to_disabled_liste=True,
        add_to_enabled_liste=True):
        
        if width: widjet.setFixedWidth(width)
        if height: widjet.setFixedHeight(height)
        if font: widjet.setFont(font)
        if add_to_disabled_liste: self.tool_disabled.append(widjet)
        if add_to_enabled_liste: self.tool_enabled.append(widjet)
        
        self.toolbar_chaine.addWidget(widjet)

    """Create the menu entries and toolbar icons inside the QGIS GUI."""
    def initGui(self):
        self.tool_button_intervalle = None
    
        # QFont for lables
        font_lable = QFont()
        font_lable.setPointSize(9)
        font_lable.setBold(True)
        # QFont for lineedits
        font_rep = QFont()
        font_rep.setPointSize(9)
        
        # ------------------ Action des parametres ------------------
        self.action_parametre = self.add_action(
            name='Paramètre',
            help_str='Ouvrir la fenêtre des paramètres',
            add_to_toolbar=True,
            add_to_menu=True,
            callback=self.openFenetreParametres,
            parent=self.iface.mainWindow())
        
        # ------------------ Action du suivi du RTSS/chainage ------------------
        self.tracingChainage = self.add_action(
            name='Suivre le chainage',
            help_str='Suivre le chainage selon la position de la souris',
            callback=self.actionChainage,
            parent=self.iface.mainWindow(),
            add_to_menu=False,
            add_to_disabled_liste=True,
            add_to_enabled_liste=True,
            isCheckable=True)
            
        # ------------------ Widjet lable RTSS ------------------
        self.lbl_rtss = QLabel()
        self.lbl_rtss.setText(' RTSS: ')
        self.add_widjet(self.lbl_rtss, font=font_lable, height=20)
        
        # ------------------ Widjet LineEdit RTSS ------------------
        self.txt_rtss = QLineEdit()
        self.txt_rtss.mousePressEvent = lambda _ : self.txt_rtss.selectAll()
        self.txt_rtss.setFrame(False)
        self.add_widjet(self.txt_rtss, font=font_rep, height=20, width=130)
        
        # ------------------ Widjet lable chainage ------------------
        self.lbl_chainage = QLabel()
        self.lbl_chainage.setText(' Chainage: ')
        self.add_widjet(self.lbl_chainage, font=font_lable, height=20)
        
        # ------------------ Widjet LineEdit chainage ------------------
        self.txt_chainage = QLineEdit()
        self.txt_chainage.mousePressEvent = lambda _ : self.txt_chainage.selectAll()
        self.txt_chainage.setFrame(False)
        self.add_widjet(self.txt_chainage, font=font_rep, height=20, width=60)
        self.suivi_chainage_is_connected = False
        
        # ------------------ Action de mesure le long d'un rtss ------------------
        self.action_mesurer = self.add_action(
            name="Mesurer un chainage",
            help_str='Mesurer une longueur sur un RTSS',
            callback=self.maptoolMesurer,
            add_to_menu=False,
            add_to_disabled_liste=True,
            add_to_enabled_liste=True,
            isCheckable=True,
            parent=self.iface.mainWindow())
        
        # Vérifier que l'action de mesurer une distance est dans la barre d'outil
        if self.action_mesurer:
            # ------------------ Widjet lable distance ------------------
            self.lbl_distance = QLabel()
            self.lbl_distance.setFont(font_lable)
            self.lbl_distance.setText(' Distance: ')
            self.add_widjet(self.lbl_distance, font=font_lable, height=20)
            
           
            # ------------------ Widjet LineEdit distance ------------------
            self.txt_distance = QLineEdit()
            self.txt_distance.mousePressEvent = lambda _ : self.txt_distance.selectAll()
            self.txt_distance.setFrame(False)
            self.txt_distance.setReadOnly(True)
            self.add_widjet(self.txt_distance, font=font_rep, height=20, width=60)
            
        
        # ------------------ Menu ------------------
        # Groupe des actions
        # Vérifier si plus d'une action du groupe est active
        if len(self.gestion_parametre.getActionsInGroupe("intervalle")) > 1:
            self.tool_button_intervalle = QToolButton()
            self.tool_button_intervalle.setMenu(QMenu())
            self.tool_button_intervalle.setPopupMode(QToolButton.MenuButtonPopup)
            self.toolbar_chaine.addWidget(self.tool_button_intervalle)
            add_toolbar = False
        else: add_toolbar = True
        
        # ------------------ Action afficher l'interval de chainage ------------------
        self.actionAfficherChainage = self.add_action(
            name="Calculer un interval de chainage",
            help_str='Calculer le chainage selon un intervalle pour les RTSS sélectionnés',
            callback=self.openFenetreIntervalChainage,
            parent=self.iface.mainWindow(),
            add_to_menu=False,
            add_to_toolbar=add_toolbar,
            isCheckable=False,
            add_to_disabled_liste=True,
            enabled_flag=False)
            
        # ------------------ Action afficher des transects ------------------
        self.actionAfficherTransects = self.add_action(
            name="Calculer des transects",
            help_str='Calculer des transects le long des RTSS sélectionnés',
            callback=self.openFenetreTransect,
            parent=self.iface.mainWindow(),
            add_to_menu=False,
            add_to_toolbar=add_toolbar,
            isCheckable=False,
            add_to_disabled_liste=True,
            enabled_flag=False)
            
        # ------------------ Action afficher des atlas ------------------
        self.actionAfficherAtlas = self.add_action(
            name="Calculer des atlas",
            help_str='Calculer des atlas le long des RTSS sélectionnés',
            callback=self.openFenetreIntervalChainage,
            parent=self.iface.mainWindow(),
            add_to_menu=False,
            add_to_toolbar=add_toolbar,
            isCheckable=False,
            add_to_disabled_liste=True,
            enabled_flag=False)
            
        if not add_toolbar:
            first_action = True
            # Ajouter les actions au menu
            for action in [self.actionAfficherChainage, self.actionAfficherTransects, self.actionAfficherAtlas]:
                if action:
                    self.tool_button_intervalle.menu().addAction(action)
                    if first_action:
                        self.tool_button_intervalle.setDefaultAction(action)
                        first_action = False
            # Garder la dernière action trigger comme l'action par défault
            self.tool_button_intervalle.triggered.connect(self.tool_button_intervalle.setDefaultAction)
        
        # ------------------ Action de placer des écussons ------------------
        self.action_add_ecusson = self.add_action(
            name="Placer des écussons",
            help_str='Placer des écussons sur la carte',
            callback=self.maptoolAddNewEcusson,
            parent=self.iface.mainWindow(),
            isCheckable=True,
            add_to_disabled_liste=True,
            add_to_enabled_liste=True,
            add_to_menu=False)
            
        # ------------------ Action de création de geometrie ------------------
        self.action_create_geometrie = self.add_action(
            name="Creation de geometrie",
            help_str="Numérisation d'une entitées par RTSS/chainage",
            callback=self.openFenetreCreateFeature,
            parent=self.iface.mainWindow(),
            isCheckable=True,
            add_to_disabled_liste=True,
            add_to_enabled_liste=True,
            add_to_menu=False)
        
        # ------------------ Ouvrir une fenêtre SVN ------------------
        self.action_open_svn = self.add_action(
            name="Open SVN",
            help_str='Ouvrir un emplacement dans SVN',
            callback=self.maptoolopenSVN,
            add_to_disabled_liste=True,
            add_to_enabled_liste=True,
            isCheckable=True,
            parent=self.iface.mainWindow(),
            add_to_menu=False)
        
        # ------------------ Ouvrir une fenêtre SIGO ------------------
        self.action_open_sigo = self.add_action(
            name="Open SIGO",
            help_str='Ouvrir la vue courante dans SIGO',
            callback=lambda: openSIGO(self.iface),
            parent=self.iface.mainWindow(),
            add_to_menu=False)
            
        # ------------------ Action d'aides ------------------
        self.action_open_help = self.add_action(
            name='Aide',
            help_str='Aide sur le plugin',
            callback=lambda: os.startfile(self.documentation),
            parent=self.iface.mainWindow())
        
        # Rendre la tool bar inactive jusqu'au démarage du plugin
        for widjet in self.tool_disabled: widjet.setEnabled(False)
        
        # Ajouter les scripts au provider
        self.provider = Provider()
        QgsApplication.processingRegistry().addProvider(self.provider)
        
        self.setPluginActive()
    #--------------------------------------------------------------------------
    
    """ Removes the plugin menu item and icon from QGIS GUI."""
    def unload(self):
        # Retirer les scripts
        if self.provider: QgsApplication.processingRegistry().removeProvider(self.provider)
        
        self.setPluginInactive()
        # Retirer les Qaction du menu et de la barre d'outils 
        for action in self.actions:
            self.iface.removePluginMenu(self.menu_name, action)
            self.iface.removeToolBarIcon(action)
        
        self.canvas.layersChanged.disconnect(self.setPluginActive)
        # Retirer de la carte les géometries temporaire
        self.canvas.scene().removeItem(self.vertex_marker_snap)
        #self.canvas.scene().removeItem(self.segment_offset_temporaire)
        self.canvas.scene().removeItem(self.mouse_text)
        
        for dlg in [self.dlg_params, self.dlg_add_feat, self.dlg_interval_chainage]:
            if dlg: dlg.close()
            
        # remove the toolbar
        del self.toolbar_chaine
    
    """ Méthode qui instancie et affiche la fenêtre des paramètres """
    def openFenetreParametres(self):
        if self.dlg_params: self.dlg_params.close()
        
        self.dlg_params = fenetreParametre()
        
        self.setPluginInactive()
        self.dlg_params.closing_window.connect(self.closeFenetreParametres)
        self.dlg_params.dockLocationChanged.connect(lambda area: self.gestion_parametre.getParam("dlg_param_last_pos").setValue(area))
        
        # Show the dockwidget
        self.iface.addTabifiedDockWidget(self.gestion_parametre.getParam("dlg_param_last_pos").getValue(), self.dlg_params, raiseTab=True)
        self.dlg_params.show()
        
    def closeFenetreParametres (self):
        if self.dlg_params:
            self.dlg_params.closing_window.disconnect(self.closeFenetreParametres)
            self.dlg_params.dockLocationChanged.disconnect()
            self.dlg_params.close()
            self.dlg_params = None
            
            self.setPluginActive()
            
    """ Méthode qui instancie et affiche la fenêtre du choix d'interval de chainage """
    def openFenetreIntervalChainage(self):
        if not self.dlg_interval_chainage:
            # Instance de la fenêtre
            self.dlg_interval_chainage = fenetreSelectionInterval()
            # Apppler la fonction lorsque l'interval est accepter par l'utilisateur
            self.dlg_interval_chainage.buttonBox.accepted.connect(self.afficherIntervalChainage)
            self.dlg_interval_chainage.buttonBox.rejected.connect(self.closeFenetreIntervalChainage)
            self.dlg_interval_chainage.closing_window.connect(self.closeFenetreIntervalChainage)
        # Afficher la fenêtre
        self.dlg_interval_chainage.show()
        self.dlg_interval_chainage.activateWindow()        

    def closeFenetreIntervalChainage(self):
        if self.dlg_interval_chainage:
            # Déconnecter
            self.dlg_interval_chainage.buttonBox.accepted.disconnect(self.afficherIntervalChainage)
            self.dlg_interval_chainage.buttonBox.rejected.disconnect(self.closeFenetreIntervalChainage)
            self.dlg_interval_chainage.closing_window.disconnect(self.closeFenetreIntervalChainage)
            
            self.dlg_interval_chainage.close()
            self.dlg_interval_chainage = None               
    
    """ Méthode qui instancie et affiche la fenêtre du choix d'interval de chainage """
    def openFenetreTransect(self):
        if not self.dlg_transect:
            # Instance de la fenêtre
            self.dlg_transect = fenetreTransect()
            # Apppler la fonction lorsque l'interval est accepter par l'utilisateur
            self.dlg_transect.buttonBox.accepted.connect(self.afficherTransect)
            self.dlg_transect.buttonBox.rejected.connect(self.closeFenetreTransect)
            self.dlg_transect.closing_window.connect(self.closeFenetreTransect)
        
        # Afficher la fenêtre
        self.dlg_transect.show()
        self.dlg_transect.activateWindow()

    def closeFenetreTransect(self):
        if self.dlg_transect:
            # Déconnecter
            self.dlg_transect.buttonBox.accepted.disconnect(self.afficherTransect)
            self.dlg_transect.buttonBox.rejected.disconnect(self.closeFenetreTransect)
            self.dlg_transect.closing_window.disconnect(self.closeFenetreTransect)
            
            self.dlg_transect.close()
            self.dlg_transect = None             
    
    def openFenetreCreateFeature(self):
        if self.dlg_add_feat: self.dlg_add_feat.close()
        # Instance de la fenêtre
        self.dlg_add_feat = fenetreAddFeature(self.iface, self.layer_rtss, self.geocode)
        self.dlg_add_feat.closing_window.connect(self.closeFenetreCreateFeature)
        self.dlg_add_feat.dockLocationChanged.connect(lambda area: self.gestion_parametre.getParam("dlg_add_feat_last_pos").setValue(area))
        
        # show the dockwidget
        self.iface.addTabifiedDockWidget(self.gestion_parametre.getParam("dlg_add_feat_last_pos").getValue(), self.dlg_add_feat, raiseTab=True)
        # Afficher la fenêtre
        self.dlg_add_feat.show()     

    def closeFenetreCreateFeature(self):
        if self.dlg_add_feat:
            # Déconnecter
            self.dlg_add_feat.closing_window.disconnect(self.closeFenetreCreateFeature)
            self.dlg_add_feat.dockLocationChanged.disconnect()
            
            self.dlg_add_feat.close()
            self.dlg_add_feat = None      
    
    """ 
        Méthode qui permet de démarer l'utilisation du Plugin.
        Fait quelque chose seulement si le plugin n'est pas déjà actif
    """
    def setPluginActive(self):
        try:
            # Vérifier si le plugin doit être mis actif
            if not self.plugin_is_active:
                message = "Oups! Un problème est survenu avec la recherche de la couche des RTSS..."
                layer = validateLayer(
                    self.gestion_parametre.getParam("layer_rtss").getValue(),
                    fields_name=[self.gestion_parametre.getParam("field_num_rtss").getValue(), self.gestion_parametre.getParam("field_chainage_fin").getValue()],
                    geom_type=1)
                # Initialiser la référence du RTSS
                if layer:
                    # Définir les informations importantes pour le plugin
                    self.layer_rtss = layer
                    message = "Oups! Un problème est survenu avec les connections aux signaux..."
                    # Connecter les changement de CRS du canvas
                    self.canvas.destinationCrsChanged.connect(self.updateTransformContext)
                    self.layer_rtss.selectionChanged.connect(self.afficherActionWithSelection)
                    # TODO check if other layer can be use after
                    self.layer_rtss.willBeDeleted.connect(self.setPluginInactive)
                    # Connecter la recherche
                    self.txt_rtss.returnPressed.connect(self.zoomToFeat)
                    self.txt_chainage.returnPressed.connect(self.zoomToFeat)
                    message = "Oups! Un problème est survenu avec le module de géocodage..."
                    self.updateGeocode()
                    message = "Oups! Un problème est survenu avec la définition des entitées visible..."
                    if self.gestion_parametre.getParam("use_only_on_visible").getValue(): self.layer_rtss.repaintRequested.connect(self.updateGeocode)
                    
                    message = "Oups! Un problème est survenu avec les raccourcis..."
                    # Vérifier que l'action de suivre le chainage est dans la barre d'outil
                    if self.tracingChainage and self.gestion_parametre.getParam("use_raccourcis_chainage"):
                        shortcut_key = self.gestion_parametre.getParam("raccourcis_clavier").getValue()
                        if shortcut_key and self.gestion_parametre.getParam("use_raccourcis_chainage").getValue(): self.tracingChainage.setShortcut(QKeySequence(shortcut_key))
                        else: self.action_add_ecusson.setShortcut("")
                        
                    # Vérifier que l'action de placer des écussons est dans la barre d'outil
                    if self.action_add_ecusson:
                        shortcut_key = self.gestion_parametre.getParam("raccourcis_clavier_ecusson").getValue()
                        if shortcut_key and self.gestion_parametre.getParam("use_raccourcis_ecusson").getValue(): self.action_add_ecusson.setShortcut(QKeySequence(shortcut_key))
                        else: self.action_add_ecusson.setShortcut("")
                    
                    message = "Oups! Un problème est survenu avec la barre d'outil..."
                    # Appliquer le Completer au LineEdit
                    self.setRtssCompleter()
                    
                    # Définir le text par défault de la distance
                    if self.action_mesurer: self.txt_distance.setText(formaterChainage(0, self.gestion_parametre.getParam("precision_chainage").getValue()))
                    
                    if self.action_create_geometrie:
                        self.updateActionIcon()
                        self.iface.currentLayerChanged.connect(self.updateActionIcon)
                    
                    # Rendre la tool bar active
                    for widjet in self.tool_enabled: widjet.setEnabled(True)
                    
                    # Définir la police du tooltip a affihcer sur la carte
                    self.mouse_text.setFont(self.gestion_parametre.getParam("font_on_map").getValue())
                    self.html_tooltip = '<p style="color:%s"><i>{}</i></p>' % self.gestion_parametre.getParam("color_font_on_map").getValue()
                    
                    # Set la transformation du CRS
                    self.updateTransformContext()
                    # Indicateur que le plugin est actif
                    self.plugin_is_active = True
                    
                    # Activer l'action d'intervalle de chainage si des RTSS sont selectionnées
                    self.afficherActionWithSelection(self.layer_rtss.selectedFeatureIds())
        except:
            # Indiquer à l'utilisateur que l'entité à bien été ajouter
            widget = self.iface.messageBar().createMessage(message)
            # Afficher le message
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
    
    
    """ 
        Méthode qui permet d'annuler l'utilisation du Plugin.
        Fait quelque chose seulement si le plugin est actif
    """
    def setPluginInactive(self):
        if self.plugin_is_active:
            self.plugin_is_active = False
            
            # Vérifier si le suivi du chainage est connecter
            if self.suivi_chainage_is_connected:
                # Déconnecter le suivi du chainage
                self.tracingChainage.setChecked(False)
                self.actionChainage(False)
            
            # Déconnecter la couche des RTSS
            self.layer_rtss.selectionChanged.disconnect(self.afficherActionWithSelection)
            self.layer_rtss.willBeDeleted.disconnect(self.setPluginInactive)
            if self.gestion_parametre.getParam("use_only_on_visible").getValue(): self.layer_rtss.repaintRequested.disconnect(self.updateGeocode)
            
            # Déconnecter la recherche
            self.txt_rtss.returnPressed.disconnect(self.zoomToFeat)
            self.txt_chainage.returnPressed.disconnect(self.zoomToFeat)
            if self.action_create_geometrie: self.iface.currentLayerChanged.disconnect(self.updateActionIcon)
            # Déconnecter le canvas
            self.canvas.destinationCrsChanged.disconnect(self.updateTransformContext)
            
            # Déconnecter les outils
            for tools in [self.tool_mesurer, self.tool_add_ecusson, self.tool_open_svn]:
                if tools: tools.deactivate()
            # Reset tools 
            self.tool_mesurer = None
            self.tool_add_ecusson = None
            self.tool_open_svn = None
            
            for widjet in self.tool_disabled: widjet.setEnabled(False)
    
    def getModuleGeocodage(self):
        if self.plugin_is_active: return self.geocode
        
        # Indiquer à l'utilisateur que l'entité à bien été ajouter
        widget = self.iface.messageBar().createMessage("Le plugin n'est pas actif! Aucun module de geocodage n'est défini")
        # Afficher le message
        self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
        return None
    
    def setRtssCompleter(self):
        try:
            # Créer le completer
            completer = QCompleter(self.geocode.getListRTSS(self.gestion_parametre.getParam("formater_rtss").getValue(), sorted=True))
            completer.setCaseSensitivity(0)
            completer.setModelSorting(2)
            # Appliquer le Completer au LineEdit
            self.txt_rtss.setCompleter(completer)
        except Exception as error:
            # Indiquer à l'utilisateur que l'entité à bien été ajouter
            widget = self.iface.messageBar().createMessage(f'Attention!: {error}')
            # Afficher le message
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)        
    
    """
        Bouton qui active et désactive les actions et widjets en lien avec la couche RTSS

        Entrée: 
            - active (bool) = Determine si le bouton est activé ou désactivé  
    """
    def actionChainage(self, active):
        # Vérifie si le bouton est activé et si la couche d'index 
        if active and self.plugin_is_active:
            self.suivi_chainage_is_connected = True
            self.canvas.xyCoordinates.connect(self.updateSuiviDuChainage)
            self.updateGeocode()
            
        elif self.suivi_chainage_is_connected:
            self.suivi_chainage_is_connected = False
            self.canvas.xyCoordinates.disconnect(self.updateSuiviDuChainage)
            # Retirer de la carte les géometries temporaire
            self.vertex_marker_snap.hide()
            #self.segment_offset_temporaire.reset()
            self.mouse_text.hide()
    
    def updateSuiviDuChainage(self, point_on_map):
        try:
            message = "Oups! Un problème est survenu dans la reprojection..."
            # Reproject le point du cursor
            if self.need_reprojection: point = self.crs_transform.transform(point_on_map)
            else: point = point_on_map
            
            message = "Oups! Un problème est survenu dans le géocodage de la position de la souris..."
            # Get le point sur le rtss et chainage le plus proche du cursor
            point_on_rtss, num_rtss, chainage, dist = self.geocode.getPointOnRTSS(
                point,
                formater_rtss=self.gestion_parametre.getParam("formater_rtss").getValue(),
                formater_chainage=self.gestion_parametre.getParam("formater_chainage").getValue())
            
            angle = self.geocode.getAngleAtChainage(num_rtss, chainage) + self.canvas.rotation()
            
            message = "Oups! Un problème est survenu dans la reprojection..."
            # Reprojecter le point sur le rtss si nécéssaire
            if self.need_reprojection: point_on_rtss = self.crs_reverse_transform.transform(point_on_rtss.asPoint())
            else: point_on_rtss = point_on_rtss.asPoint()
            #geom = QgsGeometry().fromPolylineXY([point_on_rtss, point_on_map])
            
            message = "Oups! Le point n'a pas pu être placer..."
            # Place le pointeur au chainage
            self.vertex_marker_snap.setCenter(point_on_rtss)
            self.vertex_marker_snap.show()
            
            #self.segment_offset_temporaire.setToGeometry(geom)
            #self.segment_offset_temporaire.show()
            message = "Oups! Un problème est avec le tooltip..."
            # Liste des textes possible à afficher sur la carte
            text_a_afficher = [["show_rtss_on_map", num_rtss], ["show_chainage_on_map", str(chainage)], ["show_distance_on_map", str(round(dist,1)) + ' m']]
            # Liste des textes à afficher sur la carte selon les paramètres
            text_a_afficher = [val for param_name, val in text_a_afficher if self.gestion_parametre.getParam(param_name).getValue()]
            # Vérifier s'il y a des text à afficher
            if text_a_afficher:
                # Définir le text a afficher sur la carte
                #self.mouse_text.setHtml('<p style="background-color:rgba(200, 200, 200, 0.5)"><i>{}</i></p>'.format('<br>'.join(text_a_afficher)))
                self.mouse_text.setHtml(self.html_tooltip.format('<br>'.join(text_a_afficher)))
                # Postion du chainage sur la carte en pixel
                pos = self.canvas.getCoordinateTransform().transform(point_on_rtss)
                x, y = getToolTipPosition(pos, text_a_afficher, angle)
                # Placer le text avec un offset
                self.mouse_text.setPos(x, y)
                # Afficher le text sur la carte
                self.mouse_text.show()
            # Sinon cacher le text
            else: self.mouse_text.hide()
            
        except:
            # Indiquer à l'utilisateur que l'entité à bien été ajouter
            widget = self.iface.messageBar().createMessage(message)
            # Afficher le message
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
            self.tracingChainage.trigger()
            num_rtss, chainage = '', ''
            
        # Actualiser les valeurs dans la barre d'outils
        self.txt_chainage.setText(str(chainage))
        self.txt_rtss.setText(num_rtss)
    

    """
        Méthode qui instancie l'outil de mesure d'une longueur de chainage le long d'un RTSS.
        
        Entrée:
            - active (bool) = Indicateur de l'état de l'outil. Actif ou Inactif
    """
    def maptoolMesurer(self, active):
        # Si le plugin est actif et l'outil n'est pas déjà actif
        if active and self.plugin_is_active:
            self.updateGeocode()
            # Instancier le mapTool
            if not self.tool_mesurer:
                self.tool_mesurer = MtqMapToolLongueurRTSS(self.canvas, self.layer_rtss, self.geocode)
                # Définir le cursor
                self.tool_mesurer.mCursor = QgsApplication.getThemeCursor(3)
                # Set le bouton pour arrêter le mapTool
                self.tool_mesurer.setAction(self.action_mesurer)
            
            self.tool_mesurer.lastMapTool(self.canvas.mapTool())
            self.tool_mesurer.currentDistance.connect(lambda dist: self.txt_distance.setText(dist))
            # Activé le mapTool
            self.canvas.setMapTool(self.tool_mesurer)
        # Désactivé le mapTool s'il est actif
        else:
            self.tool_mesurer.deactivate()
            self.tool_mesurer.currentDistance.disconnect()
    
    """
        Méthode qui instancie l'outil d'ajout d'écussons.
        
        Entrée:
            - active (bool) = Indicateur de l'état de l'outil. Actif ou Inactif
    """
    def maptoolAddNewEcusson(self, active):
        if active and self.plugin_is_active:
            self.updateGeocode()       
            # Instancier le mapTool
            if not self.tool_add_ecusson:
                # Créer le maptool
                self.tool_add_ecusson = MtqMapToolNewEcusson(self.canvas, self.layer_rtss, self.geocode)
                # Set Cursor
                self.tool_add_ecusson.mCursor = QgsApplication.getThemeCursor(3)
                # Définir l'action de l'outils
                self.tool_add_ecusson.setAction(self.action_add_ecusson)
            # Définir la couche des écussons
            layer_ecusson = validateLayer(
                self.gestion_parametre.getParam("layer_ecusson_name").getValue(),
                fields_name=[self.gestion_parametre.getParam("layer_ecusson_field_route").getValue()],
                geom_type=0)
            # Créer la couche si elle n'exists pas
            if not layer_ecusson:
                layer_ecusson = self.tool_add_ecusson.createNewLayer()
                path_to_ecusson = os.path.join(self.gestion_parametre.getParam("ecusson_path").getValue(), "styles")
                QgsExpressionContextUtils.setLayerVariable(layer_ecusson, 'path_to_ecusson', path_to_ecusson)
            # Idiquer la référence de la couche au maptool 
            self.tool_add_ecusson.setLayerEcusson(layer_ecusson)
            # Conserver le dernier maptool
            self.tool_add_ecusson.lastMapTool(self.canvas.mapTool())
            # L'outils est actif dans la carte
            self.canvas.setMapTool(self.tool_add_ecusson)
        
        else: self.tool_add_ecusson.deactivate()
        
        
    def maptoolopenSVN(self, active):
        if active and self.plugin_is_active:
            # Instancier le mapTool
            if not self.tool_open_svn:
                self.tool_open_svn = MtqMapToolOpenSVN(self.canvas, self.geocode, self.layer_rtss)
                # Définir l'action de l'outils
                self.tool_open_svn.setAction(self.action_open_svn)
                
            self.tool_open_svn.lastMapTool(self.canvas.mapTool())
            # L'outils est actif dans la carte
            self.canvas.setMapTool(self.tool_open_svn)
        else: self.tool_open_svn.deactivate()
            
    
    """
        Méthode qui fait appelle à un script pour générer les points de chaînage
        le long des RTSS selectionnés et selon l'interval défini par l'utilisateur.
        La méthode est appeller lorsque le bouton "ok" de la fenêtre du choix d'interval
        est clické.
    """
    def afficherIntervalChainage (self):
        # L'interval défini dans la fenêtre par l'utilisateur
        interval = self.dlg_interval_chainage.spx_intervalle.value()
        # Définir la source pour la couche des RTSS en entrée avec seulement les entitées selectionnés 
        rtss = QgsProcessingFeatureSourceDefinition(self.gestion_parametre.getParam("layer_rtss").getValue(), True)
        # Définir les paramètres du script
        params = {'INPUT_RTSS': rtss,
                'INPUT_FIELD_LONG': self.geocode.nom_champ_long,
                'INPUT_FIELD_RTSS': self.geocode.nom_champ_rtss,
                'INPUT_INTERVAL': interval,
                'OUTPUT': f"memory:Chainage ({interval}m)"}
        # Lancer le script "Générer des point de chaînage sur un RTSS"
        result = processing.run("MTQ:generateChainagePointOnRTSS", params)
        # La couche vectorielle (point) résultante du script 
        addLayerToMap(self.canvas, result['OUTPUT'], style=self.gestion_parametre.getParam("layer_chainage_style").getValue())
    
    def afficherTransect(self):
        distance_droite = self.dlg_transect.spx_dist_droite.value()
        distance_gauche = self.dlg_transect.spx_dist_gauche.value()
        # L'interval défini dans la fenêtre par l'utilisateur
        interval = self.dlg_transect.spx_intervalle.value()
        inverse = not self.dlg_transect.chk_inverser.isChecked()
        
        # Définir la source pour la couche des RTSS en entrée avec seulement les entitées selectionnés 
        rtss = QgsProcessingFeatureSourceDefinition(self.gestion_parametre.getParam("layer_rtss").getValue(), True)
        # Définir les paramètres du script
        params = {'INPUT_RTSS': rtss,
                'LONG': self.geocode.nom_champ_long,
                'RTSS': self.geocode.nom_champ_rtss,
                'INPUT_INTERVAL': interval,
                'INPUT_LINE_LENGTH_DROITE': distance_droite,
                'INPUT_LINE_LENGTH_GAUCHE': distance_gauche,
                'INVERSE':inverse,
                'OUTPUT': f"memory:Transects"}
        # Lancer le script "Générer des point de chaînage sur un RTSS"
        result = processing.run("MTQ:generateTransect", params)
        # La couche vectorielle (point) résultante du script 
        addLayerToMap(self.canvas, result['OUTPUT'])
        
    
    """
        Méthode qui contrôle l'activation de l'outil "Afficher le chainage".
        Elle est connectée au changement de selection de la couche des RTSS.
        
        Entrée:
            - ids (list) = Les ids des entitées selectionnées
    """
    def afficherActionWithSelection (self, ids):
        # Si des entitées sont selectionnées, l'outil peut être utilisé
        if self.plugin_is_active: 
            is_active = bool(ids)
            if self.actionAfficherChainage: self.actionAfficherChainage.setEnabled(is_active)
            if self.actionAfficherTransects: self.actionAfficherTransects.setEnabled(is_active)
            if self.actionAfficherAtlas: self.actionAfficherAtlas.setEnabled(is_active)
        
    
    def updateGeocode(self):
        # Aller chercher seulement les entités visible si l'option est choisi
        if self.gestion_parametre.getParam("use_only_on_visible").getValue(): features = getVisibleFeatures(self.layer_rtss)
        # Sinon aller chercher toutes les entitées de la couche
        else: features = self.layer_rtss.getFeatures()
        try:
            if self.gestion_parametre.getParam("field_chainage_debut").getValue() == "": field_chainage_debut = None
            else: field_chainage_debut = self.gestion_parametre.getParam("field_chainage_debut").getValue()
            # Mettre à jour la référence des RTSS du module de géocodage 
            self.geocode.updateReferenceDesRTSS(
                features,
                self.layer_rtss.crs(),
                self.gestion_parametre.getParam("field_num_rtss").getValue(), 
                self.gestion_parametre.getParam("field_chainage_fin").getValue(),
                field_chainage_debut)
            
            self.geocode.setPrecision(self.gestion_parametre.getParam("precision_chainage").getValue())
            # TODO: set precision
        except Exception as error:
            # Indiquer à l'utilisateur que l'entité à bien été ajouter
            widget = self.iface.messageBar().createMessage(f'Attention!: {error}')
            # Afficher le message
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
        
        self.setRtssCompleter()
    
    """ Méthode qui suis les modifications de la projection de la carte """
    def updateTransformContext(self):
        # Set le CRS de la carte
        map_crs = QgsProject.instance().crs()
        rtss_crs = self.layer_rtss.crs()
        self.need_reprojection = map_crs != rtss_crs
        # Set la class QgsCoordinateTransform qui permet de faire la projection entre 2 CRS
        # Carte => Couche RTSS
        self.crs_transform = QgsCoordinateTransform(map_crs, rtss_crs, QgsProject.instance())
        # Couche RTSS => Carte
        self.crs_reverse_transform = QgsCoordinateTransform(rtss_crs, map_crs, QgsProject.instance())
    
    """
        Zoom sur les entitées de la couche du ComboBox dont leur valeur pour le
        champ de recherche configurer est égale à la valeur rentrer dans le LineEdit. 
    """    
    def zoomToFeat(self):
        try:
            message = "Oups! Un problème est survenu avec la recherche..."
            # Numéro du RTSS et Chainage
            rtss, chainage = self.txt_rtss.text(), verifyFormatChainage(self.txt_chainage.text())
            flash_geom = []
            extent = QgsRectangle()
            # Parcourir les objets featRTSS pour le numéro de route cherché
            for feat_rtss in self.geocode.getRTSS(rtss, rtss_complet=False):
                # Zoom sur le RTSS ou une partie dépendament du chainage
                if chainage:
                    # Portion du RTSS autour du chainage
                    geom = feat_rtss.getLineFromChainage(chainage-100, chainage +100)
                    flash_geom.append(feat_rtss.getPointFromChainage(chainage))
                else:
                    geom = feat_rtss.getGeometry()
                    flash_geom.append(geom)
                extent.combineExtentWith(geom.boundingBox())
                    
            if flash_geom:
                message = "Oups! Un problème est survenu avec le repérange dans la carte..."
                # Vérifier si le bounding box doit être reprojeté
                if self.need_reprojection: extent = self.crs_reverse_transform.transform(extent)
                # Déplacer la carte sur le bounding box du RTSS
                self.canvas.zoomToFeatureExtent(extent)
                # Raffraichir la carte
                self.canvas.refresh()
                # Faire clignoter les entitées resultants 
                self.canvas.flashGeometries(flash_geom, self.geocode.getCrs(), flashes=3, duration=500)
        except:
            # Indiquer à l'utilisateur que l'entité à bien été ajouter
            widget = self.iface.messageBar().createMessage(message)
            # Afficher le message
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
        
    def updateActionIcon(self):
        # Disable the Button by default
        self.action_create_geometrie.setEnabled(False)
        layer = self.iface.activeLayer()
        
        if layer:
            # Only for vector layers.
            if layer.type() == 0:
                # Only for line and points
                if layer.geometryType() == 0 or layer.geometryType() == 1:
                    self.action_create_geometrie.setEnabled(layer.isEditable())
                    # disconnect, will be reconnected
                    try: layer.editingStarted.disconnect(self.updateActionIcon) 
                    except: pass
                    # when it becomes active layer again
                    try: layer.editingStopped.disconnect(self.updateActionIcon) 
                    except: pass
                    layer.editingStarted.connect(self.updateActionIcon)
                    layer.editingStopped.connect(self.updateActionIcon)
                    # Change icon
                    if layer.geometryType() == 0: self.action_create_geometrie.setIcon(QIcon(os.path.join(self.plugin_dir, 'icons/create_point.png')))
                    else: self.action_create_geometrie.setIcon(QIcon(os.path.join(self.plugin_dir, 'icons/create_line.png')))
                
    
    def checkForPluginUpdate(self):
        try:
            if self.gestion_parametre.getParam("suivi_plugin_update").getValue():
                plugins_path = self.gestion_parametre.getParam("dossier_plugin_update").getValue()
                # Vérifier que le chemin est valide
                if os.path.exists(plugins_path):
                    # Inisialiser la nouvelle version avec la version courant
                    new_version = self.version
                    # Parcourir les fichiers du répertoire des plugins
                    for plugin_file in os.listdir(plugins_path):
                        try:
                            # Vérifier si le ficher est un fichier compressé 
                            if plugin_file[-4:] == '.zip' :
                                # Garder seulement la portion du numéro de version
                                plugin_file_version = plugin_file[:-4].split('_v')[1]
                                # Comparer la version du fichier ZIP dans le répertoire avec la nouvelle version courante
                                if version.parse(new_version) < version.parse(plugin_file_version): 
                                    # La version du ZIP est plus récente que la version courante
                                    new_version = plugin_file_version
                                    # Garder le chemin vers le ZIP
                                    new_plugin = os.path.join(plugins_path, plugin_file)
                        except: continue
                    # Vérifier si une nouvelle version à été trouvé
                    if new_version != self.version:
                        self.new_plugin = new_plugin
                        # Vérifier si une nouvelle version à été trouvé
                        text = ('<b>Une nouvelle version du plugin de chainage est disponible!</b>'
                                ' La version %s est disponible pour installation') % (new_version)
                        popWidget = self.iface.messageBar().createMessage(text)
                        button = QPushButton(popWidget)
                        button.setText("Installer")
                        button.pressed.connect(self.installNewVersion)
                        popWidget.layout().addWidget(button)
                        a = self.iface.messageBar().pushWidget(popWidget, 0)
        except: pass
    
    def installNewVersion(self):
        self.iface.messageBar().popWidget(self.iface.messageBar().currentItem())
        pyplugin_installer.instance().installFromZipFile(self.new_plugin)
        
    
pass

                
                
                
                
