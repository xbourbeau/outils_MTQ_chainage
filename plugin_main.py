# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OutilsMTQ
                                 A QGIS plugin
 Regroupe les outils pratiques
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Xavier Bourbeau
        email                : xavier.bourbeau@transports.gouv.qc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Import QGIS
from qgis.PyQt.QtGui import QIcon, QKeySequence
from qgis.PyQt.QtWidgets import QAction, QCompleter, QToolButton, QMenu
from qgis.core import (QgsProject, QgsPointXY, QgsApplication, QgsCoordinateTransform,
                       QgsRectangle, Qgis, QgsExpression)
from qgis.gui import QgsMapMouseEvent, QgisInterface

# Import General
import os

# Import from Plugin
from .modules.provider import Provider

# Import Interfaces
from .interfaces.fenetre_parametre import fenetreParametre
from .interfaces.fenetre_selection_interval import fenetreSelectionInterval
from .interfaces.fenetre_transect import fenetreTransect
from .interfaces.fenetre_create_atlas import fenetreCreateAtlas
from .interfaces.fenetre_geocodage_inverse import fenetreGeocodageInverse

from .maptool.mtq_maptool_distance_rtss import MtqMapToolLongueurRTSS
from .maptool.mtq_maptool_new_ecusson import MtqMapToolNewEcusson
from .maptool.mtq_maptool_open_svn import MtqMapToolOpenSVN
from .maptool.mtq_maptool_creer_geometry import MtqMapToolCreerGeometry

from .modules.PluginUpdates import PluginUpdates
from .modules.ToolbarWidjet import ToolbarWidjet
from .modules.TemporaryGeometry import TemporaryGeometry
from .modules.PluginParametres import PluginParametres

from .tasks.TaskGenerateReseauSegementation import TaskGenerateReseauSegementation

from .mtq.core import Geocodage, Chainage, PointRTSS, ReseauSegmenter
from .mtq.functions import openSIGO, validateLayer
from .mtq.utils import Utilitaire as Utils

from .functions.getVisibleFeatures import getVisibleFeatures
from .functions.getToolTipPosition import getToolTipPosition
from .functions.getIcon import getIcon

from .expressions.expression_geocodage import *

# DEV: Ajouter l'option d'ouvrir la fenêtre de Géocodage
# DEV: Add link to open folder of installation

class MtqPluginChainage:
    """ QGIS Plugin Implementation."""

    def __init__(self, iface:QgisInterface):
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # ******  À CHANGER LORS DE NOUVELLE MISE À JOUR **********
        version = "3.3.1"
        self.documentation = "file://sstao00-adm005/TridentAnalyst/Plugin_chainage_mtq/Documentation/Index.html"
        # *********************************************************

        # Declare instance attributes
        self.actions = []
        # Liste des actions pouvant êtres disabled
        self.plugin_active_actions = []
        self.actions_selection_rtss = []
        # Liste des Outils (QgsMapTools) nécéssitant une référence à la couche des RTSS
        self.maptools_needing_layer = []
        self.menu_name = u"&Outils de chainage (MTQ)"
        self.menu = self.menu_name
        # Interfaces
        self.plugin_active_dlg = []
        self.plugin_dlg = []
        
        # ToolBar des outils de chainage
        self.toolbar_chaine = self.iface.addToolBar(u'Outils chainage (MTQ)')
        
        # Référence du provider des scripts de géotraitment
        # Ajouter les scripts au provider
        self.provider = Provider()
        QgsApplication.processingRegistry().addProvider(self.provider)    
        # Indicateur de l'état du plugin
        self.plugin_is_active = False
        # Class qui gère l'enregistrement des paramètres
        self.params = PluginParametres()
        
        # Information de la couche RTSS
        self.layer_rtss = None
        # Instance de la class geocodage 
        self.geocode = Geocodage(
            rtss_features=None,
            crs=None,
            nom_champ_rtss=self.params.getValue("field_num_rtss"), 
            nom_champ_long=self.params.getValue("field_chainage_fin"),
            nom_champ_chainage_d=self.params.getValue("field_chainage_debut"),
            precision=self.params.getValue("precision_chainage"))
        # Réseau segmenter 
        self.reseau_context = ReseauSegmenter(self.geocode)
        
        # Reférence à la carte
        self.canvas = self.iface.mapCanvas()
        # Vérifier si le plugin peut être lancée si une couche est ajouter au projet
        self.canvas.layersChanged.connect(self.setPluginActive)
        
        # Define le pointeur du chainage
        self.vertex_marker_snap = TemporaryGeometry.createMarkerChainage(self.canvas)
        self.vertex_marker_snap.hide()
        
        # Définir le text pour le suivi du chainage
        self.mouse_text = self.canvas.scene().addText("")
        self.mouse_text.hide()
        
        # Module qui verifie les nouvelles versions du plugin
        self.plugin_updates = PluginUpdates(self.iface, version)
        self.plugin_updates.checkForPluginUpdate()

    def add_action(
        self,
        name,
        help_str,
        callback,
        enabled_flag=True,
        add_to_active_plugin=False,
        active_on_rtss_selection=False,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        isCheckable=False):
        
        action = None
        param_action = self.params.getAction(name)
        if param_action:
            if param_action.get():
                icon = QIcon(param_action.getIcon())
                action = QAction(icon, help_str, parent)
                action.triggered.connect(callback)
                action.setCheckable(isCheckable)
                action.setEnabled(enabled_flag)

                if status_tip is not None: action.setStatusTip(status_tip)
                if whats_this is not None: action.setWhatsThis(whats_this)
                if add_to_toolbar: self.toolbar_chaine.addAction(action)
                if add_to_menu: self.iface.addPluginToMenu(self.menu,action)
                if add_to_active_plugin: self.plugin_active_actions.append(action)
                if active_on_rtss_selection: self.actions_selection_rtss.append(action)

                self.actions.append(action)

        return action
    
    def add_widjet(
        self,
        widjet,
        width=None,
        height=None,
        font=None,
        add_to_active_plugin=True):
        
        if width: widjet.setFixedWidth(width)
        if height: widjet.setFixedHeight(height)
        if font: widjet.setFont(font)
        if add_to_active_plugin: self.plugin_active_actions.append(widjet)
        
        self.toolbar_chaine.addWidget(widjet)

    def initGui(self):
        """ Create the menu entries and toolbar icons inside the QGIS GUI."""
        # QFont for lables
        font_lable = ToolbarWidjet.createLableFont()
        # QFont for lineedits
        font_rep = ToolbarWidjet.createLineEditFont()
        
        # ------------------ Action des parametres ------------------
        dlg_params = fenetreParametre(self.iface)
        action_parametre = self.add_action(
            name='Paramètre',
            help_str='Ouvrir la fenêtre des paramètres',
            add_to_toolbar=True,
            add_to_menu=True,
            callback=dlg_params.setInterfaceActive,
            parent=self.iface.mainWindow())
        dlg_params.plugin_actif.connect(self.setPluginActive)
        dlg_params.plugin_inactif.connect(self.setPluginInactive)
        dlg_params.generate_index.connect(self.generateContextLayerIndex)
        dlg_params.delete_index.connect(self.deleteContextLayerIndex)
        self.plugin_dlg.append(dlg_params)
        
        # ------------------ Action du suivi du RTSS/chainage ------------------
        self.tracingChainage = self.add_action(
            name='Suivre le chainage',
            help_str='Suivre le chainage selon la position de la souris',
            callback=self.actionChainage,
            parent=self.iface.mainWindow(),
            add_to_menu=False,
            add_to_active_plugin=True,
            isCheckable=True)

        # ------------------ Widjet lable RTSS ------------------
        self.add_widjet(ToolbarWidjet.createLable(" RTSS: "), font=font_lable, height=20)
        # ------------------ Widjet LineEdit RTSS ------------------
        self.txt_rtss = ToolbarWidjet.createLineEdit()
        self.add_widjet(self.txt_rtss, font=font_rep, height=20, width=130)
        self.txt_rtss.returnPressed.connect(self.zoomToFeat)
        # ------------------ Widjet lable chainage ------------------
        self.add_widjet(ToolbarWidjet.createLable(" Chainage: "), font=font_lable, height=20)
        # ------------------ Widjet LineEdit chainage -----------------
        self.txt_chainage = ToolbarWidjet.createLineEdit()
        self.add_widjet(self.txt_chainage, font=font_rep, height=20, width=60)
        self.txt_chainage.returnPressed.connect(self.zoomToFeatChainage)
        self.suivi_chainage_is_connected = False
        # ------------------ Widjet LineEdit distance ------------------
        self.txt_distance = ToolbarWidjet.createLineEdit(read_only=True)
            
        # ------------------ Action de mesure le long d'un rtss ------------------
        tool_mesurer = MtqMapToolLongueurRTSS(self.canvas, self.geocode, self.txt_distance)
        action_mesurer = self.add_action(
            name="Mesurer un chainage",
            help_str='Mesurer une longueur sur un RTSS',
            callback=lambda active: self.canvas.setMapTool(tool_mesurer) if active else tool_mesurer.action().setChecked(True),
            add_to_menu=False,
            add_to_active_plugin=True,
            isCheckable=True,
            parent=self.iface.mainWindow())
        # Set le bouton pour arrêter le mapTool
        tool_mesurer.setAction(action_mesurer)
        self.maptools_needing_layer.append(tool_mesurer)

        # Vérifier que l'action de mesurer une distance est dans la barre d'outil
        if action_mesurer:
            # ------------------ Widjet lable distance ------------------
            self.add_widjet(ToolbarWidjet.createLable(" Distance: "), font=font_lable, height=20)
            self.add_widjet(self.txt_distance, font=font_rep, height=20, width=60)
            
        # ------------------ Menu ------------------
        # Groupe des actions
        # Vérifier si plus d'une action du groupe est active
        if len(self.params.getActionsInGroupe("intervalle")) > 1:
            tool_button_intervalle = QToolButton()
            tool_button_intervalle.setMenu(QMenu())
            tool_button_intervalle.setPopupMode(QToolButton.MenuButtonPopup)
            self.toolbar_chaine.addWidget(tool_button_intervalle)
            add_toolbar = False
        else: add_toolbar = True
        list_of_group_selection = []
        
        # ------------------ Action afficher l'interval de chainage ------------------
        # Instance de la fenêtre
        dlg_interval_chainage = fenetreSelectionInterval(self.canvas)
        actionAfficherChainage = self.add_action(
            name="Calculer un interval de chainage",
            help_str='Calculer le chainage selon un intervalle pour les RTSS sélectionnés',
            callback=dlg_interval_chainage.setInterfaceActive,
            parent=self.iface.mainWindow(),
            add_to_menu=False,
            add_to_toolbar=add_toolbar,
            isCheckable=False,
            add_to_active_plugin=True,
            active_on_rtss_selection=True,
            enabled_flag=False)
        self.plugin_active_dlg.append(dlg_interval_chainage)
        list_of_group_selection.append(actionAfficherChainage)
            
        # ------------------ Action afficher des transects ------------------
        # Instance de la fenêtre
        dlg_transect = fenetreTransect(self.canvas)
        actionAfficherTransects = self.add_action(
            name="Calculer des transects",
            help_str='Calculer des transects le long des RTSS sélectionnés',
            callback=dlg_transect.setInterfaceActive,
            parent=self.iface.mainWindow(),
            add_to_menu=False,
            add_to_toolbar=add_toolbar,
            isCheckable=False,
            add_to_active_plugin=True,
            active_on_rtss_selection=True,
            enabled_flag=False)
        self.plugin_active_dlg.append(dlg_transect)
        list_of_group_selection.append(actionAfficherTransects)
            
        # ------------------ Action afficher des atlas ------------------
        dlg_atlas = fenetreCreateAtlas(self.iface, self.geocode)
        actionAfficherAtlas = self.add_action(
            name="Calculer des atlas",
            help_str='Calculer des atlas le long des RTSS sélectionnés',
            callback=dlg_atlas.setInterfaceActive,
            parent=self.iface.mainWindow(),
            add_to_menu=False,
            add_to_toolbar=add_toolbar,
            isCheckable=False,
            add_to_active_plugin=True,
            active_on_rtss_selection=True,
            enabled_flag=False)
        self.plugin_active_dlg.append(dlg_atlas)
        list_of_group_selection.append(actionAfficherAtlas)
        self.maptools_needing_layer.append(dlg_atlas)
            
        if not add_toolbar:
            first_action = True
            # Ajouter les actions au menu
            for action in list_of_group_selection:
                if action:
                    tool_button_intervalle.menu().addAction(action)
                    if first_action:
                        tool_button_intervalle.setDefaultAction(action)
                        first_action = False
            # Garder la dernière action trigger comme l'action par défault
            tool_button_intervalle.triggered.connect(tool_button_intervalle.setDefaultAction)
        
        # ------------------ Action de placer des écussons ------------------
        # Créer le maptool
        tool_add_ecusson = MtqMapToolNewEcusson(self.canvas, self.geocode)
        self.action_add_ecusson = self.add_action(
            name="Placer des écussons",
            help_str='Placer des écussons sur la carte',
            callback=lambda active: self.canvas.setMapTool(tool_add_ecusson) if active else tool_add_ecusson.action().setChecked(True),
            parent=self.iface.mainWindow(),
            isCheckable=True,
            add_to_active_plugin=True,
            add_to_menu=False)
        # Définir l'action de l'outils
        tool_add_ecusson.setAction(self.action_add_ecusson)
        self.maptools_needing_layer.append(tool_add_ecusson)
            
        # ------------------ Action de création de geometrie ------------------
        tool_create_feat = MtqMapToolCreerGeometry(self.iface, self.geocode)
        self.action_create_geometrie = self.add_action(
            name="Creation de geometrie",
            help_str="Numérisation par RTSS/chainage",
            callback=lambda active: self.canvas.setMapTool(tool_create_feat) if active else tool_create_feat.action().setChecked(True),
            parent=self.iface.mainWindow(),
            isCheckable=True,
            add_to_active_plugin=True,
            add_to_menu=False)
        # Définir l'action de l'outils
        tool_create_feat.setAction(self.action_create_geometrie)
        self.maptools_needing_layer.append(tool_create_feat)

        # ------------------ Action de géocodage inverse ------------------
        dlg_geocodage_inverse = fenetreGeocodageInverse(self.iface, self.geocode, self.reseau_context)
        action_geocodage_inverse = self.add_action(
            name="Geocodage inverse",
            help_str="Géocoder les RTSS/chainage d'une couche",
            callback=dlg_geocodage_inverse.setInterfaceActive,
            parent=self.iface.mainWindow(),
            isCheckable=False,
            add_to_active_plugin=True,
            add_to_menu=False)
        self.plugin_active_dlg.append(dlg_geocodage_inverse)
        
        # ------------------ Ouvrir une fenêtre SVN ------------------
        tool_open_svn = MtqMapToolOpenSVN(self.canvas, self.geocode)
        action_open_svn = self.add_action(
            name="Open SVN",
            help_str='Ouvrir un emplacement dans SVN',
            callback=lambda active: self.canvas.setMapTool(tool_open_svn) if active else tool_open_svn.action().setChecked(True),
            add_to_active_plugin=True,
            isCheckable=True,
            parent=self.iface.mainWindow(),
            add_to_menu=False)
        # Définir l'action de l'outils
        tool_open_svn.setAction(action_open_svn)
        self.maptools_needing_layer.append(tool_open_svn)
        
        # ------------------ Ouvrir une fenêtre SIGO ------------------
        action_open_sigo = self.add_action(
            name="Open SIGO",
            help_str='Ouvrir la vue courante dans SIGO',
            callback=lambda: openSIGO(self.iface),
            parent=self.iface.mainWindow(),
            add_to_menu=False)
            
        # ------------------ Action d'aides ------------------
        action_open_help = self.add_action(
            name='Aide',
            help_str='Aide sur le plugin',
            callback=lambda: os.startfile(self.documentation),
            parent=self.iface.mainWindow())
        
        # Rendre la tool bar inactive jusqu'au démarage du plugin
        for widjet in self.plugin_active_actions: widjet.setEnabled(False)
        
        self.setPluginActive()
 
    def unload(self):
        """ Removes the plugin menu item and icon from QGIS GUI."""
        # Retirer les scripts
        if self.provider: QgsApplication.processingRegistry().removeProvider(self.provider)
        # Désactiver le plugin
        try: self.setPluginInactive()
        except: pass
        # Fermer toute les fenêtres du plugin
        for dlg in self.plugin_dlg: dlg.close()
        # Retirer les Qaction du menu et de la barre d'outils 
        for action in self.actions:
            self.iface.removePluginMenu(self.menu_name, action)
            self.iface.removeToolBarIcon(action)
        
        self.canvas.layersChanged.disconnect(self.setPluginActive)
        # Retirer de la carte les géometries temporaire
        self.canvas.scene().removeItem(self.vertex_marker_snap)
        self.canvas.scene().removeItem(self.mouse_text)
        # remove the toolbar
        del self.toolbar_chaine
        # Éffacer la couche de contexte
        del self.reseau_context
        del self.geocode
    
    def setPluginActive(self):
        """ 
        Méthode qui permet de démarer l'utilisation du Plugin.
        Fait quelque chose seulement si le plugin n'est pas déjà actif
        """
        # Vérifier si le plugin doit être mis actif
        if self.plugin_is_active: return None
        # Initialiser la référence du RTSS
        if not self.setLayerRTSS(): return None
        
        try:
            # Connecter les changement de CRS du canvas
            self.canvas.destinationCrsChanged.connect(self.updateTransformContext)
            self.layer_rtss.selectionChanged.connect(self.afficherActionWithSelection)
            # TODO check if other layer can be use after
            self.layer_rtss.willBeDeleted.connect(self.setPluginInactive)
            if self.params.getValue("use_only_on_visible"): self.layer_rtss.repaintRequested.connect(self.updateGeocode)
            if self.action_create_geometrie: self.iface.currentLayerChanged.connect(self.updateActionIcon)
            if self.params.showContextMenu(): self.canvas.contextMenuAboutToShow.connect(self.populateContextMenu)
        # Afficher le message
        except: return Utils.criticalMessage(
            self.iface, "Oups! Un problème est survenu avec les connections aux signaux...")
        
        try:
            # Définir le text par défault de la distance
            if self.txt_distance: self.txt_distance.setText(Chainage(0).valueFormater(self.params.getValue("precision_chainage")))
                
            for maptool in self.maptools_needing_layer: maptool.setLayer(self.layer_rtss.id())
            #if self.actionAfficherAtlas: self.dlg_atlas.setLayerRTSS(self.layer_rtss.id())
            # Rendre la toolbar active
            for widjet in self.plugin_active_actions: widjet.setEnabled(True)
        # Afficher le message
        except: return Utils.criticalMessage(
            self.iface, "Oups! Un problème est survenu dans l'initialisation de la barre d'outil")

        # Définir le module de Géocodage
        if not self.updateGeocode(): return None
        # Vérifier que l'action de suivre le chainage est dans la barre d'outil
        if not self.setRaccourciChainage(): return None
        # Vérifier que l'action de placer des écussons est dans la barre d'outil
        if not self.setRaccourciEcusson(): return None
        # Définir la police du tooltip a affihcer sur la carte
        if not self.setTooltipStyle(): return None
        # Activer l'action d'intervalle de chainage si des RTSS sont selectionnées
        if not self.afficherActionWithSelection(self.layer_rtss.selectedFeatureIds()): return None
        # Set la transformation du CRS
        if not self.updateTransformContext(): return None
        # Définir l'icon de l'outil de création d'entitée
        if not self.updateActionIcon(): return None
        # Load customs expressions using the plugin
        try: self.loadCustomExpressions()
        except: Utils.warningMessage(self.iface, "Les expressions du plugin n'ont pas pu être chargé!")
        # Indicateur que le plugin est actif
        self.plugin_is_active = True

    def setPluginInactive(self):
        """ 
        Méthode qui permet d'annuler l'utilisation du Plugin.
        Fait quelque chose seulement si le plugin est actif
        """
        if not self.plugin_is_active: return None
        self.plugin_is_active = False
        
        # Vérifier si le suivi du chainage est connecter
        if self.suivi_chainage_is_connected:
            # Déconnecter le suivi du chainage
            self.tracingChainage.setChecked(False)
            self.actionChainage(False)
        try:
            # Déconnecter la couche des RTSS
            self.layer_rtss.selectionChanged.disconnect(self.afficherActionWithSelection)
            # BUG: Crash if layer delete and expressions are used
            self.layer_rtss.willBeDeleted.disconnect(self.setPluginInactive)
            if self.params.getValue("use_only_on_visible"): self.layer_rtss.repaintRequested.disconnect(self.updateGeocode)
            if self.params.showContextMenu(): self.canvas.contextMenuAboutToShow.disconnect(self.populateContextMenu)
        except: pass
        if self.action_create_geometrie: self.iface.currentLayerChanged.disconnect(self.updateActionIcon)
        # Déconnecter le canvas
        self.canvas.destinationCrsChanged.disconnect(self.updateTransformContext)

        # Unload customs expressions using the plugin 
        try: self.unloadCustomExpressions()
        except: pass

        # Disable current maptool if it's a custom plugin maptool
        if self.canvas.mapTool(): 
            if self.canvas.mapTool().action() in self.plugin_active_actions: 
                self.canvas.mapTool().action().setChecked(False)
                self.canvas.mapTool().deactivate()
        
        # Rendre la toolbar active
        for widjet in self.plugin_active_actions: widjet.setEnabled(False)
        # Fermer toutes les fenêtres s'il sont ouverte
        for dlg in self.plugin_active_dlg: dlg.close()

    def unloadCustomExpressions(self):
        if self.params.getValue("load_custom_expressions"):
            QgsExpression.unregisterFunction('get_rtss')
            QgsExpression.unregisterFunction('get_rtss_formater')
            QgsExpression.unregisterFunction('get_chainage')
            QgsExpression.unregisterFunction('get_chainage_formater')
            QgsExpression.unregisterFunction('get_distance_to_rtss')
            QgsExpression.unregisterFunction('geocoder_line')
            QgsExpression.unregisterFunction('geocoder_point')
            QgsExpression.unregisterFunction('geocoder_polygon')

    def loadCustomExpressions(self):
        if self.params.getValue("load_custom_expressions"):
            QgsExpression.registerFunction(get_rtss)
            QgsExpression.registerFunction(get_rtss_formater) 
            QgsExpression.registerFunction(get_chainage) 
            QgsExpression.registerFunction(get_chainage_formater) 
            QgsExpression.registerFunction(get_distance_to_rtss)
            QgsExpression.registerFunction(geocoder_line) 
            QgsExpression.registerFunction(geocoder_point)
            QgsExpression.registerFunction(geocoder_polygon) 

    def setLayerRTSS(self):
        try:
            # Initialiser la référence du RTSS
            self.layer_rtss = validateLayer(
                self.params.getValue("layer_rtss"),
                fields_name=[self.params.getValue("field_num_rtss"), self.params.getValue("field_chainage_fin")],
                geom_type=1)
            return self.layer_rtss is not None
        # Afficher le message
        except: 
            Utils.criticalMessage(
                iface=self.iface,
                message="Oups! Un problème est survenu avec la recherche de la couche des RTSS...",
                subject="Set Layer RTSS: ")
            return False
    
    def setTooltipStyle(self):
        """ Permet de définir la police et la couleur tu tooltip dans la carte """
        try:
            # Définir la police du tooltip a affihcer sur la carte
            self.mouse_text.setFont(self.params.getValue("font_on_map"))
            self.html_tooltip = '<p style="color:%s"><i>{}</i></p>' % self.params.getValue("color_font_on_map")
            return True
        except: Utils.warningMessage(
            iface=self.iface,
            message="Oups! Un problème est survenu dans la définition du tooltip dans la carte",
            subject="Tooltip style: ")
        return False

    def getModuleGeocodage(self):
        if self.plugin_is_active: return self.geocode
        # Indiquer à l'utilisateur que l'entité à bien été ajouter
        widget = self.iface.messageBar().createMessage("Le plugin n'est pas actif! Aucun module de geocodage n'est défini")
        # Afficher le message
        self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
        return None
    
    def setRtssCompleter(self):
        try:
            # Créer le completer
            completer = QCompleter(self.geocode.getListRTSS(self.params.getValue("formater_rtss"), sorted=True))
            completer.setCaseSensitivity(0)
            completer.setModelSorting(2)
            # Appliquer le Completer au LineEdit
            self.txt_rtss.setCompleter(completer)
        except Exception as error:
            # Indiquer à l'utilisateur que l'entité à bien été ajouter
            widget = self.iface.messageBar().createMessage(f'Attention!: {error}')
            # Afficher le message
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)        
    
    def actionChainage(self, active):
        """
        Bouton qui active et désactive les actions et widjets en lien avec la couche RTSS

        Args: 
            - active (bool): Determine si le bouton est activé ou désactivé  
        """ 
        # Vérifie si le bouton est activé et si la couche d'index 
        if active and self.plugin_is_active:
            self.suivi_chainage_is_connected = True
            self.canvas.xyCoordinates.connect(self.updateSuiviDuChainage)
        elif self.suivi_chainage_is_connected:
            self.suivi_chainage_is_connected = False
            self.canvas.xyCoordinates.disconnect(self.updateSuiviDuChainage)
            # Retirer de la carte les géometries temporaire
            if not self.params.getValue("keep_marker_suivi_chainage"): self.vertex_marker_snap.hide()
            self.mouse_text.hide()
    
    def setReseauSegementation(self):
        """ Permet de définir le module du réseau segmenté à partir de la tache terminer """
        self.reseau_context.setModuleGeocodage(self.task_generate_reseau.geocode)
        self.reseau_context.setReseau(self.task_generate_reseau.getReseau())
        self.task_generate_reseau = None
        Utils.succesMessage(self.iface, "Le réseau a été généré avec succès!", subject="Réseau segmentation linéaire: ")

    def generateContextLayerIndex(self):
        """ Permet de créer et exécuter la tache de génération du réseau segmenté """
        try:
            field_value = self.params.getValue("field_context_value")
            field_rtss = self.params.getValue("field_context_route")
            layer_name = self.params.getValue("context_layer")
            # Valider si la couche de context est valide
            layer_context = validateLayer(layer_name, fields_name=[field_value], geom_type=1)
            # Retourner False si la couche de context n'est pas valide
            if layer_context is None: return False
            # Définir le champs des numéros de routes
            if not validateLayer(layer_name, fields_name=[field_value, field_rtss], geom_type=1) is None:
                field_rtss = [field_rtss]
            else: field_rtss = []
            # Créer la tâche
            self.task_generate_reseau = TaskGenerateReseauSegementation(
                geocode=self.geocode,
                layer_context=layer_context,
                field_value=field_value,
                field_rtss=field_rtss,
                interval=self.params.getValue("intervalle_interpolation"),
                dist_max=self.params.getValue("dist_interpolation"))
            self.task_generate_reseau.taskCompleted.connect(self.setReseauSegementation)
            QgsApplication.taskManager().addTask(self.task_generate_reseau)
            Utils.InfoMessage(self.iface, "Débuter la tâche de génération du réseau...", subject="Réseau segmentation linéaire: ")
        except Exception as error:
            Utils.criticalMessage(
                iface=self.iface,
                message="Oups! Un problème est survenu en créant le module du réseau de segmentation linéaire pour la couche de context",
                subject="Réseau segmentation linéaire: ")
            return False

    def deleteContextLayerIndex(self):
        if self.reseau_context.isEmpty(): return None
        self.reseau_context.clear()
        Utils.succesMessage(self.iface, "Le réseau à été supprimer", subject="Réseau segmentation linéaire: ")

    def getElementFromReseau(self, point_rtss:PointRTSS):
        if self.reseau_context.isEmpty(): return None
        try:
            elems = self.reseau_context.getElementsFromPointRTSS(point_rtss)
            if elems != []: return elems[0].getAttribut(self.params.getValue("field_context_value"))
        except: pass
        return None

    def updateSuiviDuChainage(self, point_on_map:QgsPointXY):
        try:
            message = "Oups! Un problème est survenu dans la reprojection..."
            # Reproject le point du cursor
            if self.need_reprojection: point = self.crs_transform.transform(point_on_map)
            else: point = point_on_map
            
            message = "Oups! Un problème est survenu dans le géocodage de la position de la souris..."
            # Get le point sur le rtss et chainage le plus proche du cursor
            point_rtss = self.geocode.geocoderInversePoint(point)
            # Définir le numéro du RTSS
            num_rtss = point_rtss.getRTSS(formater=self.params.getValue("formater_rtss"))
            # Définir le chainage arrondi 
            chainage = point_rtss.getChainage(
                formater=self.params.getValue("formater_chainage"),
                precision=self.params.getValue("precision_chainage"))
            # Changer la position du marqueur pour le chainage arrondi
            if self.params.getValue("pos_marqueur_arrondi"): point_rtss.setChainage(chainage)
            # Géocoder le point sur le RTSS
            point_on_rtss = self.geocode.geocoderPoint(point_rtss, on_rtss=True).asPoint()
            message = "Oups! Un problème est survenu dans la reprojection..."
            # Reprojecter le point sur le rtss si nécéssaire
            if self.need_reprojection: point_on_rtss = self.crs_reverse_transform.transform(point_on_rtss)
            message = "Oups! Le point n'a pas pu être placer..."
            # Place le pointeur au chainage
            self.vertex_marker_snap.setCenter(point_on_rtss)
            self.vertex_marker_snap.show()
            
            message = "Oups! Un problème est avec le tooltip..."
            # Définir le format en fonction de la précision
            precision = self.params.getValue("precision_distance")
            number_format = "{:.%if} m" % (precision if precision >= 0 else 0)
            dist = number_format.format(round(point_rtss.getOffset(), precision))
            
            val_context = self.getElementFromReseau(point_rtss)
            # Liste des textes possible à afficher sur la carte
            text_a_afficher = [["show_rtss_on_map", num_rtss],
                               ["show_chainage_on_map", chainage],
                               ["show_distance_on_map", dist],
                               ["show_context_on_map", val_context]]
            # Liste des textes à afficher sur la carte selon les paramètres
            text_a_afficher = [str(val) for param_name, val in text_a_afficher if self.params.getValue(param_name) and val != None]
            # Vérifier s'il y a des text à afficher
            if text_a_afficher:
                # Définir le text a afficher sur la carte
                self.mouse_text.setHtml(self.html_tooltip.format('<br>'.join(text_a_afficher)))
                # Postion du chainage sur la carte en pixel
                pos = self.canvas.getCoordinateTransform().transform(point_on_rtss)
                 # Définir l'angle de la route au point
                angle = self.geocode.getAngle(point_rtss) + self.canvas.rotation()
                x, y = getToolTipPosition(pos, text_a_afficher, angle)
                # Placer le text avec un offset
                self.mouse_text.setPos(x, y)
                # Afficher le text sur la carte
                self.mouse_text.show()
            # Sinon cacher le text
            else: self.mouse_text.hide()
        except:
            # Indiquer à l'utilisateur que l'entité à bien été ajouter
            widget = self.iface.messageBar().createMessage(message)
            # Afficher le message
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=3)
            self.tracingChainage.trigger()
            num_rtss, chainage = '', ''
            
        # Actualiser les valeurs dans la barre d'outils
        self.txt_chainage.setText(chainage)
        self.txt_rtss.setText(num_rtss)
             
    def populateContextMenu(self, menu:QMenu, event:QgsMapMouseEvent):
        """
        Méthode que permet d'ajouter des options au menu du clique droit dans la carte
        """
        # Reproject le point du cursor
        if self.need_reprojection: point = self.crs_transform.transform(event.mapPoint())
        else: point = event.mapPoint()
        # Get le point sur le rtss et chainage le plus proche du cursor
        point_rtss = self.geocode.geocoderInversePoint(point)
        feat_rtss = self.geocode.get(point_rtss.getRTSS())
        # Définir les valeurs de RTSS/chainage
        rtss, chainage, dist = point_rtss.getRTSS(), point_rtss.getChainage(), point_rtss.getOffset()
        # Ajouter un sous menu pour copier les informations du RTSS
        subMenu = menu.addMenu('Copier les informations du RTSS')

        if feat_rtss and self.params.getValue("show_copie_menu_info"):
            # Ajouter une section au sous menu
            subMenu.addSection("Info sur RTSS: ")
            # Ajouter les actions de copie des valeurs
            action_copier_chainage_fin = subMenu.addAction(
                f'Chainage de fin ({feat_rtss.chainageFin()})')
            # Connecter les actions au copie du press papier
            if feat_rtss: action_copier_chainage_fin.triggered.connect(
                lambda *args: QgsApplication.clipboard().setText(str(feat_rtss.chainageFin())))
        
        if self.params.getValue("show_copie_menu_non_formater"):
            # Ajouter une section au sous menu
            subMenu.addSection("Valeurs: ")
            # Ajouter les actions de copie des valeurs
            action_copier_rtss = subMenu.addAction(
                f'RTSS ({rtss.value()})')
            actionaction_copier_chainage = subMenu.addAction(
                f'Chaînage ({chainage.value(precision=self.params.getValue("precision_chainage"))})')
            actionTrace = subMenu.addAction(f'Copier la distance trace ({round(dist, self.params.getValue("precision_distance"))})')
            actionTrace.triggered.connect(
                lambda *args: QgsApplication.clipboard().setText(dist))
            action_copier_tout = subMenu.addAction(
                f'Numéro du RTSS et chaînage ({rtss.value()} {chainage.value(precision=self.params.getValue("precision_chainage"))})')
            action_copier_rtss.triggered.connect(
                lambda *args: QgsApplication.clipboard().setText(rtss.value()))
            actionaction_copier_chainage.triggered.connect(
                lambda *args: QgsApplication.clipboard().setText(str(chainage.value())))
            action_copier_tout.triggered.connect(
                lambda *args: QgsApplication.clipboard().setText(f'{rtss.value()} {chainage.value(precision=self.params.getValue("precision_chainage"))}'))

        if self.params.getValue("show_copie_menu_formater"):
            # Ajouter une section au sous menu
            subMenu.addSection("Valeurs formatté: ")
            # Ajouter les actions de copie des valeurs formatté
            action_copier_rtss_formater = subMenu.addAction(
                f'RTSS ({rtss.valueFormater()})')
            action_copier_rtss_formater.triggered.connect(
                lambda *args: QgsApplication.clipboard().setText(rtss.valueFormater()))
            
            action_copier_chainage_formater = subMenu.addAction(
                f'Chaînage ({chainage.valueFormater(precision=self.params.getValue("precision_chainage"))})')
            action_copier_chainage_formater.triggered.connect(
                lambda *args: QgsApplication.clipboard().setText(chainage.valueFormater(precision=self.params.getValue("precision_chainage"))))
            
            action_copier_tout_formater = subMenu.addAction(
                f'RTSS et chaînage ({rtss.valueFormater()} {chainage.valueFormater()})')
            action_copier_tout_formater.triggered.connect(
                lambda *args: QgsApplication.clipboard().setText(f'{rtss.valueFormater()} {chainage.valueFormater(precision=self.params.getValue("precision_chainage"))}'))
            
    def setRaccourciChainage(self):
        """
        Permet de définir le raccourci de suivi du chainage selon les paramètres du plugin

        Returns:
            bool: Renvoie si le raccourci a été défini correctement 
        """
        try:
            # Vérifier que l'action de suivre le chainage est dans la barre d'outil
            if self.tracingChainage and self.params.getValue("use_raccourcis_chainage"):
                shortcut_key = self.params.getValue("raccourcis_clavier")
                if shortcut_key: self.tracingChainage.setShortcut(QKeySequence(shortcut_key))
                else: self.tracingChainage.setShortcut("")
            return True
        except: Utils.criticalMessage(
            iface=self.iface,
            message="Oups! Un problème est survenu avec le raccourci de suivi du chainage...",
            subject="Set Raccourci: ")
        return False

    def setRaccourciEcusson(self):
        """
        Permet de définir le raccourci de placement d'écussons selon les paramètres du plugin

        Returns:
            bool: Renvoie si le raccourci a été défini correctement 
        """
        try:
            # Vérifier que l'action de placer des écussons est dans la barre d'outil
            if self.action_add_ecusson and self.params.getValue("use_raccourcis_ecusson"):
                shortcut_key = self.params.getValue("raccourcis_clavier_ecusson")
                if shortcut_key: self.action_add_ecusson.setShortcut(QKeySequence(shortcut_key))
                else: self.action_add_ecusson.setShortcut("")
            return True
        except: Utils.criticalMessage(
            iface=self.iface,
            message="Oups! Un problème est survenu avec le raccourci de placement d'écussons...",
            subject="Set Raccourci: ")
        return False

    def afficherActionWithSelection(self, ids):
        """
        Méthode qui contrôle l'activation de l'outil "Afficher le chainage".
        Elle est connectée au changement de selection de la couche des RTSS.
        
        Entrée:
            - ids (list) = Les ids des entitées selectionnées
        """
        try:
            # Si des entitées sont selectionnées, l'outil peut être utilisé
            for action in self.actions_selection_rtss: action.setEnabled(bool(ids))
            return True
        except: 
            Utils.warningMessage(
                iface=self.iface,
                message="Oups! Un problème est survenu en allant chercher les features des RTSS",
                subject="Module Géocodage: ")
        return False

    def updateActionIcon(self):
        if self.action_create_geometrie is None: return True
        try:
            self.action_create_geometrie.setEnabled(False)
            layer = self.iface.activeLayer()
            if layer:
                # Only for vector layers.
                if layer.type() == 0:
                    # Only for line and points
                    if layer.geometryType() in (0, 1, 2):
                        if layer.isEditable(): self.action_create_geometrie.setEnabled(True)
                        #if self.tool_create_feat.isActive(): self.tool_create_feat.updateEditingLayer(layer)
                        # disconnect, will be reconnected
                        try: layer.editingStarted.disconnect(self.updateActionIcon) 
                        except: pass
                        # when it becomes active layer again
                        try: layer.editingStopped.disconnect(self.updateActionIcon) 
                        except: pass
                        layer.editingStarted.connect(self.updateActionIcon)
                        layer.editingStopped.connect(self.updateActionIcon)
                        # Change icon
                        if layer.geometryType() == 0: self.action_create_geometrie.setIcon(getIcon("create_point"))
                        elif layer.geometryType() == 1: self.action_create_geometrie.setIcon(getIcon("create_line"))
                        elif layer.geometryType() == 2: self.action_create_geometrie.setIcon(getIcon("create_polygon"))
            return True
        except Exception as e: 
            Utils.warningMessage(
                iface=self.iface,
                message="Oups! Un problème est survenue avec l'outil de création d'entitées",
                subject="Update create feature: ")
        return False
    
    def updateGeocode(self):
        try:
            # Aller chercher seulement les entités visible si l'option est choisi
            if self.params.getValue("use_only_on_visible"): features = getVisibleFeatures(self.layer_rtss)
            # Sinon aller chercher toutes les entitées de la couche
            else: features = self.layer_rtss.getFeatures()
        except: 
            Utils.criticalMessage(
                iface=self.iface,
                message="Oups! Un problème est survenu en allant chercher les features des RTSS",
                subject="Module Géocodage: ")
            return False
        try:
            # Liste des champs de la couche des RTSS
            fields_name = [field.name() for field in self.layer_rtss.fields()]
            # Vérifier si la couche des RTSS à un champ pour le chainage de début 
            if self.params.getValue("field_chainage_debut") in fields_name:
                field_chainage_debut = self.params.getValue("field_chainage_debut")
            else: field_chainage_debut = None
            # Vérifier si la couche des RTSS à un champ pour la classification fonctionnel 
            if self.params.getValue("field_classification") in fields_name:
                field_class_fonct = self.params.getValue("field_classification")
            else: field_class_fonct = None
            # Mettre à jour la référence des RTSS du module de géocodage 
            self.geocode.updateRTSS(
                features,
                self.layer_rtss.crs(),
                self.params.getValue("field_num_rtss"), 
                self.params.getValue("field_chainage_fin"),
                field_chainage_debut,
                class_fonct=field_class_fonct)
            # Définir la précision
            self.geocode.setPrecision(self.params.getValue("precision_chainage"))
            
        except Exception as error:
            Utils.criticalMessage(
                iface=self.iface,
                message="Oups! Un problème est survenu en créant le module de Géocodage",
                subject="Module Géocodage: ")
            return False
        
        # Redéfinir le QCompleter
        try: self.setRtssCompleter()
        except: 
            Utils.criticalMessage(
                iface=self.iface,
                message="Oups! Un problème est survenu en définisant le QCompleter avec la liste des RTSS",
                subject="Module Géocodage: ")
            return False
        return True
    
    def updateTransformContext(self):
        """ Méthode qui suis les modifications de la projection de la carte """
        try:
            # Set le CRS de la carte
            map_crs = QgsProject.instance().crs()
            rtss_crs = self.layer_rtss.crs()
            self.need_reprojection = map_crs != rtss_crs
            # Set la class QgsCoordinateTransform qui permet de faire la projection entre 2 CRS
            # Carte => Couche RTSS
            self.crs_transform = QgsCoordinateTransform(map_crs, rtss_crs, QgsProject.instance())
            # Couche RTSS => Carte
            self.crs_reverse_transform = QgsCoordinateTransform(rtss_crs, map_crs, QgsProject.instance())
            return True
        except: Utils.warningMessage(
            iface=self.iface,
            message="Oups! Un problème est survenue avec la transformation du CRS",
            subject="Update transform context")
        return False

    def zoomToFeat(self, use_chainage=None):
        """
        Zoom sur les entitées de la couche du ComboBox dont leur valeur pour le
        champ de recherche configurer est égale à la valeur rentrer dans le LineEdit. 
        """  
        try:
            flash_geom = []
            extent = QgsRectangle()
            # Parcourir les objets featRTSS pour le numéro de route cherché
            for feat_rtss in self.geocode.getRTSSFromText(self.txt_rtss.text()):
                # Zoom sur le RTSS ou une partie dépendament du chainage
                if use_chainage is None:
                    extent.combineExtentWith(feat_rtss.geometry().boundingBox()) 
                    flash_geom.append(feat_rtss.geometry())
                else:
                    # Portion du RTSS autour du chainage
                    geom = feat_rtss.geocoderPointFromChainage(use_chainage)
                    flash_geom.append(geom)
                    extent.combineExtentWith(geom.buffer(100, 5).boundingBox())
        # Afficher le message
        except: Utils.warningMessage(self.iface, "Oups! Un problème est survenu avec la recherche...")
        try:
            if flash_geom:
                # Vérifier si le bounding box doit être reprojeté
                if self.need_reprojection: extent = self.crs_reverse_transform.transform(extent)
                # Déplacer la carte sur le bounding box du RTSS
                self.canvas.zoomToFeatureExtent(extent)
                # Raffraichir la carte
                self.canvas.refresh()
                # Faire clignoter les entitées resultants 
                self.canvas.flashGeometries(flash_geom, self.geocode.getCrs(), flashes=3, duration=500)
        # Afficher le message
        except: Utils.warningMessage(self.iface, "Oups! Un problème est survenu avec le repérange dans la carte...")
        
    def zoomToFeatChainage(self):
        # Numéro du RTSS et Chainage
        chainage = Chainage.verifyFormatChainage(self.txt_chainage.text())
        self.zoomToFeat(chainage)